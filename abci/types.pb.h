// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef PROTOBUF_types_2eproto__INCLUDED
#define PROTOBUF_types_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_types_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[36];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsKVPairImpl();
void InitDefaultsKVPair();
void InitDefaultsKI64PairImpl();
void InitDefaultsKI64Pair();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsRequestEchoImpl();
void InitDefaultsRequestEcho();
void InitDefaultsRequestFlushImpl();
void InitDefaultsRequestFlush();
void InitDefaultsRequestInfoImpl();
void InitDefaultsRequestInfo();
void InitDefaultsRequestSetOptionImpl();
void InitDefaultsRequestSetOption();
void InitDefaultsRequestInitChainImpl();
void InitDefaultsRequestInitChain();
void InitDefaultsRequestQueryImpl();
void InitDefaultsRequestQuery();
void InitDefaultsRequestBeginBlockImpl();
void InitDefaultsRequestBeginBlock();
void InitDefaultsRequestCheckTxImpl();
void InitDefaultsRequestCheckTx();
void InitDefaultsRequestDeliverTxImpl();
void InitDefaultsRequestDeliverTx();
void InitDefaultsRequestEndBlockImpl();
void InitDefaultsRequestEndBlock();
void InitDefaultsRequestCommitImpl();
void InitDefaultsRequestCommit();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsResponseExceptionImpl();
void InitDefaultsResponseException();
void InitDefaultsResponseEchoImpl();
void InitDefaultsResponseEcho();
void InitDefaultsResponseFlushImpl();
void InitDefaultsResponseFlush();
void InitDefaultsResponseInfoImpl();
void InitDefaultsResponseInfo();
void InitDefaultsResponseSetOptionImpl();
void InitDefaultsResponseSetOption();
void InitDefaultsResponseInitChainImpl();
void InitDefaultsResponseInitChain();
void InitDefaultsResponseQueryImpl();
void InitDefaultsResponseQuery();
void InitDefaultsResponseBeginBlockImpl();
void InitDefaultsResponseBeginBlock();
void InitDefaultsResponseCheckTxImpl();
void InitDefaultsResponseCheckTx();
void InitDefaultsResponseDeliverTxImpl();
void InitDefaultsResponseDeliverTx();
void InitDefaultsResponseEndBlockImpl();
void InitDefaultsResponseEndBlock();
void InitDefaultsResponseCommitImpl();
void InitDefaultsResponseCommit();
void InitDefaultsConsensusParamsImpl();
void InitDefaultsConsensusParams();
void InitDefaultsBlockSizeImpl();
void InitDefaultsBlockSize();
void InitDefaultsTxSizeImpl();
void InitDefaultsTxSize();
void InitDefaultsBlockGossipImpl();
void InitDefaultsBlockGossip();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsBlockIDImpl();
void InitDefaultsBlockID();
void InitDefaultsPartSetHeaderImpl();
void InitDefaultsPartSetHeader();
void InitDefaultsValidatorImpl();
void InitDefaultsValidator();
void InitDefaultsEvidenceImpl();
void InitDefaultsEvidence();
inline void InitDefaults() {
  InitDefaultsKVPair();
  InitDefaultsKI64Pair();
  InitDefaultsRequest();
  InitDefaultsRequestEcho();
  InitDefaultsRequestFlush();
  InitDefaultsRequestInfo();
  InitDefaultsRequestSetOption();
  InitDefaultsRequestInitChain();
  InitDefaultsRequestQuery();
  InitDefaultsRequestBeginBlock();
  InitDefaultsRequestCheckTx();
  InitDefaultsRequestDeliverTx();
  InitDefaultsRequestEndBlock();
  InitDefaultsRequestCommit();
  InitDefaultsResponse();
  InitDefaultsResponseException();
  InitDefaultsResponseEcho();
  InitDefaultsResponseFlush();
  InitDefaultsResponseInfo();
  InitDefaultsResponseSetOption();
  InitDefaultsResponseInitChain();
  InitDefaultsResponseQuery();
  InitDefaultsResponseBeginBlock();
  InitDefaultsResponseCheckTx();
  InitDefaultsResponseDeliverTx();
  InitDefaultsResponseEndBlock();
  InitDefaultsResponseCommit();
  InitDefaultsConsensusParams();
  InitDefaultsBlockSize();
  InitDefaultsTxSize();
  InitDefaultsBlockGossip();
  InitDefaultsHeader();
  InitDefaultsBlockID();
  InitDefaultsPartSetHeader();
  InitDefaultsValidator();
  InitDefaultsEvidence();
}
}  // namespace protobuf_types_2eproto
namespace types {
class BlockGossip;
class BlockGossipDefaultTypeInternal;
extern BlockGossipDefaultTypeInternal _BlockGossip_default_instance_;
class BlockID;
class BlockIDDefaultTypeInternal;
extern BlockIDDefaultTypeInternal _BlockID_default_instance_;
class BlockSize;
class BlockSizeDefaultTypeInternal;
extern BlockSizeDefaultTypeInternal _BlockSize_default_instance_;
class ConsensusParams;
class ConsensusParamsDefaultTypeInternal;
extern ConsensusParamsDefaultTypeInternal _ConsensusParams_default_instance_;
class Evidence;
class EvidenceDefaultTypeInternal;
extern EvidenceDefaultTypeInternal _Evidence_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class KI64Pair;
class KI64PairDefaultTypeInternal;
extern KI64PairDefaultTypeInternal _KI64Pair_default_instance_;
class KVPair;
class KVPairDefaultTypeInternal;
extern KVPairDefaultTypeInternal _KVPair_default_instance_;
class PartSetHeader;
class PartSetHeaderDefaultTypeInternal;
extern PartSetHeaderDefaultTypeInternal _PartSetHeader_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestBeginBlock;
class RequestBeginBlockDefaultTypeInternal;
extern RequestBeginBlockDefaultTypeInternal _RequestBeginBlock_default_instance_;
class RequestCheckTx;
class RequestCheckTxDefaultTypeInternal;
extern RequestCheckTxDefaultTypeInternal _RequestCheckTx_default_instance_;
class RequestCommit;
class RequestCommitDefaultTypeInternal;
extern RequestCommitDefaultTypeInternal _RequestCommit_default_instance_;
class RequestDeliverTx;
class RequestDeliverTxDefaultTypeInternal;
extern RequestDeliverTxDefaultTypeInternal _RequestDeliverTx_default_instance_;
class RequestEcho;
class RequestEchoDefaultTypeInternal;
extern RequestEchoDefaultTypeInternal _RequestEcho_default_instance_;
class RequestEndBlock;
class RequestEndBlockDefaultTypeInternal;
extern RequestEndBlockDefaultTypeInternal _RequestEndBlock_default_instance_;
class RequestFlush;
class RequestFlushDefaultTypeInternal;
extern RequestFlushDefaultTypeInternal _RequestFlush_default_instance_;
class RequestInfo;
class RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class RequestInitChain;
class RequestInitChainDefaultTypeInternal;
extern RequestInitChainDefaultTypeInternal _RequestInitChain_default_instance_;
class RequestQuery;
class RequestQueryDefaultTypeInternal;
extern RequestQueryDefaultTypeInternal _RequestQuery_default_instance_;
class RequestSetOption;
class RequestSetOptionDefaultTypeInternal;
extern RequestSetOptionDefaultTypeInternal _RequestSetOption_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseBeginBlock;
class ResponseBeginBlockDefaultTypeInternal;
extern ResponseBeginBlockDefaultTypeInternal _ResponseBeginBlock_default_instance_;
class ResponseCheckTx;
class ResponseCheckTxDefaultTypeInternal;
extern ResponseCheckTxDefaultTypeInternal _ResponseCheckTx_default_instance_;
class ResponseCommit;
class ResponseCommitDefaultTypeInternal;
extern ResponseCommitDefaultTypeInternal _ResponseCommit_default_instance_;
class ResponseDeliverTx;
class ResponseDeliverTxDefaultTypeInternal;
extern ResponseDeliverTxDefaultTypeInternal _ResponseDeliverTx_default_instance_;
class ResponseEcho;
class ResponseEchoDefaultTypeInternal;
extern ResponseEchoDefaultTypeInternal _ResponseEcho_default_instance_;
class ResponseEndBlock;
class ResponseEndBlockDefaultTypeInternal;
extern ResponseEndBlockDefaultTypeInternal _ResponseEndBlock_default_instance_;
class ResponseException;
class ResponseExceptionDefaultTypeInternal;
extern ResponseExceptionDefaultTypeInternal _ResponseException_default_instance_;
class ResponseFlush;
class ResponseFlushDefaultTypeInternal;
extern ResponseFlushDefaultTypeInternal _ResponseFlush_default_instance_;
class ResponseInfo;
class ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
class ResponseInitChain;
class ResponseInitChainDefaultTypeInternal;
extern ResponseInitChainDefaultTypeInternal _ResponseInitChain_default_instance_;
class ResponseQuery;
class ResponseQueryDefaultTypeInternal;
extern ResponseQueryDefaultTypeInternal _ResponseQuery_default_instance_;
class ResponseSetOption;
class ResponseSetOptionDefaultTypeInternal;
extern ResponseSetOptionDefaultTypeInternal _ResponseSetOption_default_instance_;
class TxSize;
class TxSizeDefaultTypeInternal;
extern TxSizeDefaultTypeInternal _TxSize_default_instance_;
class Validator;
class ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
}  // namespace types
namespace types {

// ===================================================================

class KVPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.KVPair) */ {
 public:
  KVPair();
  virtual ~KVPair();

  KVPair(const KVPair& from);

  inline KVPair& operator=(const KVPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KVPair(KVPair&& from) noexcept
    : KVPair() {
    *this = ::std::move(from);
  }

  inline KVPair& operator=(KVPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KVPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KVPair* internal_default_instance() {
    return reinterpret_cast<const KVPair*>(
               &_KVPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(KVPair* other);
  friend void swap(KVPair& a, KVPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KVPair* New() const PROTOBUF_FINAL { return New(NULL); }

  KVPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KVPair& from);
  void MergeFrom(const KVPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KVPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:types.KVPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsKVPairImpl();
};
// -------------------------------------------------------------------

class KI64Pair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.KI64Pair) */ {
 public:
  KI64Pair();
  virtual ~KI64Pair();

  KI64Pair(const KI64Pair& from);

  inline KI64Pair& operator=(const KI64Pair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KI64Pair(KI64Pair&& from) noexcept
    : KI64Pair() {
    *this = ::std::move(from);
  }

  inline KI64Pair& operator=(KI64Pair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KI64Pair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KI64Pair* internal_default_instance() {
    return reinterpret_cast<const KI64Pair*>(
               &_KI64Pair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(KI64Pair* other);
  friend void swap(KI64Pair& a, KI64Pair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KI64Pair* New() const PROTOBUF_FINAL { return New(NULL); }

  KI64Pair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KI64Pair& from);
  void MergeFrom(const KI64Pair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KI64Pair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // int64 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.KI64Pair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int64 value_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsKI64PairImpl();
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum ValueCase {
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 19,
    kEndBlock = 11,
    kCommit = 12,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.RequestEcho echo = 2;
  bool has_echo() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::types::RequestEcho& echo() const;
  ::types::RequestEcho* release_echo();
  ::types::RequestEcho* mutable_echo();
  void set_allocated_echo(::types::RequestEcho* echo);

  // .types.RequestFlush flush = 3;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  const ::types::RequestFlush& flush() const;
  ::types::RequestFlush* release_flush();
  ::types::RequestFlush* mutable_flush();
  void set_allocated_flush(::types::RequestFlush* flush);

  // .types.RequestInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::types::RequestInfo& info() const;
  ::types::RequestInfo* release_info();
  ::types::RequestInfo* mutable_info();
  void set_allocated_info(::types::RequestInfo* info);

  // .types.RequestSetOption set_option = 5;
  bool has_set_option() const;
  void clear_set_option();
  static const int kSetOptionFieldNumber = 5;
  const ::types::RequestSetOption& set_option() const;
  ::types::RequestSetOption* release_set_option();
  ::types::RequestSetOption* mutable_set_option();
  void set_allocated_set_option(::types::RequestSetOption* set_option);

  // .types.RequestInitChain init_chain = 6;
  bool has_init_chain() const;
  void clear_init_chain();
  static const int kInitChainFieldNumber = 6;
  const ::types::RequestInitChain& init_chain() const;
  ::types::RequestInitChain* release_init_chain();
  ::types::RequestInitChain* mutable_init_chain();
  void set_allocated_init_chain(::types::RequestInitChain* init_chain);

  // .types.RequestQuery query = 7;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 7;
  const ::types::RequestQuery& query() const;
  ::types::RequestQuery* release_query();
  ::types::RequestQuery* mutable_query();
  void set_allocated_query(::types::RequestQuery* query);

  // .types.RequestBeginBlock begin_block = 8;
  bool has_begin_block() const;
  void clear_begin_block();
  static const int kBeginBlockFieldNumber = 8;
  const ::types::RequestBeginBlock& begin_block() const;
  ::types::RequestBeginBlock* release_begin_block();
  ::types::RequestBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::types::RequestBeginBlock* begin_block);

  // .types.RequestCheckTx check_tx = 9;
  bool has_check_tx() const;
  void clear_check_tx();
  static const int kCheckTxFieldNumber = 9;
  const ::types::RequestCheckTx& check_tx() const;
  ::types::RequestCheckTx* release_check_tx();
  ::types::RequestCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::types::RequestCheckTx* check_tx);

  // .types.RequestDeliverTx deliver_tx = 19;
  bool has_deliver_tx() const;
  void clear_deliver_tx();
  static const int kDeliverTxFieldNumber = 19;
  const ::types::RequestDeliverTx& deliver_tx() const;
  ::types::RequestDeliverTx* release_deliver_tx();
  ::types::RequestDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::types::RequestDeliverTx* deliver_tx);

  // .types.RequestEndBlock end_block = 11;
  bool has_end_block() const;
  void clear_end_block();
  static const int kEndBlockFieldNumber = 11;
  const ::types::RequestEndBlock& end_block() const;
  ::types::RequestEndBlock* release_end_block();
  ::types::RequestEndBlock* mutable_end_block();
  void set_allocated_end_block(::types::RequestEndBlock* end_block);

  // .types.RequestCommit commit = 12;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 12;
  const ::types::RequestCommit& commit() const;
  ::types::RequestCommit* release_commit();
  ::types::RequestCommit* mutable_commit();
  void set_allocated_commit(::types::RequestCommit* commit);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:types.Request)
 private:
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::types::RequestEcho* echo_;
    ::types::RequestFlush* flush_;
    ::types::RequestInfo* info_;
    ::types::RequestSetOption* set_option_;
    ::types::RequestInitChain* init_chain_;
    ::types::RequestQuery* query_;
    ::types::RequestBeginBlock* begin_block_;
    ::types::RequestCheckTx* check_tx_;
    ::types::RequestDeliverTx* deliver_tx_;
    ::types::RequestEndBlock* end_block_;
    ::types::RequestCommit* commit_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class RequestEcho : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestEcho) */ {
 public:
  RequestEcho();
  virtual ~RequestEcho();

  RequestEcho(const RequestEcho& from);

  inline RequestEcho& operator=(const RequestEcho& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestEcho(RequestEcho&& from) noexcept
    : RequestEcho() {
    *this = ::std::move(from);
  }

  inline RequestEcho& operator=(RequestEcho&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestEcho& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestEcho* internal_default_instance() {
    return reinterpret_cast<const RequestEcho*>(
               &_RequestEcho_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RequestEcho* other);
  friend void swap(RequestEcho& a, RequestEcho& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestEcho* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestEcho* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestEcho& from);
  void MergeFrom(const RequestEcho& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:types.RequestEcho)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestEchoImpl();
};
// -------------------------------------------------------------------

class RequestFlush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestFlush) */ {
 public:
  RequestFlush();
  virtual ~RequestFlush();

  RequestFlush(const RequestFlush& from);

  inline RequestFlush& operator=(const RequestFlush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestFlush(RequestFlush&& from) noexcept
    : RequestFlush() {
    *this = ::std::move(from);
  }

  inline RequestFlush& operator=(RequestFlush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFlush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestFlush* internal_default_instance() {
    return reinterpret_cast<const RequestFlush*>(
               &_RequestFlush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RequestFlush* other);
  friend void swap(RequestFlush& a, RequestFlush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestFlush* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestFlush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestFlush& from);
  void MergeFrom(const RequestFlush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestFlush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.RequestFlush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestFlushImpl();
};
// -------------------------------------------------------------------

class RequestInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestInfo) */ {
 public:
  RequestInfo();
  virtual ~RequestInfo();

  RequestInfo(const RequestInfo& from);

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInfo(RequestInfo&& from) noexcept
    : RequestInfo() {
    *this = ::std::move(from);
  }

  inline RequestInfo& operator=(RequestInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RequestInfo* other);
  friend void swap(RequestInfo& a, RequestInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestInfo& from);
  void MergeFrom(const RequestInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:types.RequestInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestInfoImpl();
};
// -------------------------------------------------------------------

class RequestSetOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestSetOption) */ {
 public:
  RequestSetOption();
  virtual ~RequestSetOption();

  RequestSetOption(const RequestSetOption& from);

  inline RequestSetOption& operator=(const RequestSetOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestSetOption(RequestSetOption&& from) noexcept
    : RequestSetOption() {
    *this = ::std::move(from);
  }

  inline RequestSetOption& operator=(RequestSetOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSetOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSetOption* internal_default_instance() {
    return reinterpret_cast<const RequestSetOption*>(
               &_RequestSetOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RequestSetOption* other);
  friend void swap(RequestSetOption& a, RequestSetOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestSetOption* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestSetOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestSetOption& from);
  void MergeFrom(const RequestSetOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestSetOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:types.RequestSetOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestSetOptionImpl();
};
// -------------------------------------------------------------------

class RequestInitChain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestInitChain) */ {
 public:
  RequestInitChain();
  virtual ~RequestInitChain();

  RequestInitChain(const RequestInitChain& from);

  inline RequestInitChain& operator=(const RequestInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInitChain(RequestInitChain&& from) noexcept
    : RequestInitChain() {
    *this = ::std::move(from);
  }

  inline RequestInitChain& operator=(RequestInitChain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInitChain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInitChain* internal_default_instance() {
    return reinterpret_cast<const RequestInitChain*>(
               &_RequestInitChain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RequestInitChain* other);
  friend void swap(RequestInitChain& a, RequestInitChain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInitChain* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestInitChain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestInitChain& from);
  void MergeFrom(const RequestInitChain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestInitChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.Validator validators = 1;
  int validators_size() const;
  void clear_validators();
  static const int kValidatorsFieldNumber = 1;
  const ::types::Validator& validators(int index) const;
  ::types::Validator* mutable_validators(int index);
  ::types::Validator* add_validators();
  ::google::protobuf::RepeatedPtrField< ::types::Validator >*
      mutable_validators();
  const ::google::protobuf::RepeatedPtrField< ::types::Validator >&
      validators() const;

  // bytes app_state_bytes = 2;
  void clear_app_state_bytes();
  static const int kAppStateBytesFieldNumber = 2;
  const ::std::string& app_state_bytes() const;
  void set_app_state_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_app_state_bytes(::std::string&& value);
  #endif
  void set_app_state_bytes(const char* value);
  void set_app_state_bytes(const void* value, size_t size);
  ::std::string* mutable_app_state_bytes();
  ::std::string* release_app_state_bytes();
  void set_allocated_app_state_bytes(::std::string* app_state_bytes);

  // @@protoc_insertion_point(class_scope:types.RequestInitChain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::Validator > validators_;
  ::google::protobuf::internal::ArenaStringPtr app_state_bytes_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestInitChainImpl();
};
// -------------------------------------------------------------------

class RequestQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestQuery) */ {
 public:
  RequestQuery();
  virtual ~RequestQuery();

  RequestQuery(const RequestQuery& from);

  inline RequestQuery& operator=(const RequestQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuery(RequestQuery&& from) noexcept
    : RequestQuery() {
    *this = ::std::move(from);
  }

  inline RequestQuery& operator=(RequestQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuery* internal_default_instance() {
    return reinterpret_cast<const RequestQuery*>(
               &_RequestQuery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RequestQuery* other);
  friend void swap(RequestQuery& a, RequestQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuery* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestQuery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestQuery& from);
  void MergeFrom(const RequestQuery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // bool prove = 4;
  void clear_prove();
  static const int kProveFieldNumber = 4;
  bool prove() const;
  void set_prove(bool value);

  // @@protoc_insertion_point(class_scope:types.RequestQuery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 height_;
  bool prove_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestQueryImpl();
};
// -------------------------------------------------------------------

class RequestBeginBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestBeginBlock) */ {
 public:
  RequestBeginBlock();
  virtual ~RequestBeginBlock();

  RequestBeginBlock(const RequestBeginBlock& from);

  inline RequestBeginBlock& operator=(const RequestBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestBeginBlock(RequestBeginBlock&& from) noexcept
    : RequestBeginBlock() {
    *this = ::std::move(from);
  }

  inline RequestBeginBlock& operator=(RequestBeginBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBeginBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestBeginBlock* internal_default_instance() {
    return reinterpret_cast<const RequestBeginBlock*>(
               &_RequestBeginBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RequestBeginBlock* other);
  friend void swap(RequestBeginBlock& a, RequestBeginBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestBeginBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestBeginBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestBeginBlock& from);
  void MergeFrom(const RequestBeginBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestBeginBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 absent_validators = 3;
  int absent_validators_size() const;
  void clear_absent_validators();
  static const int kAbsentValidatorsFieldNumber = 3;
  ::google::protobuf::int32 absent_validators(int index) const;
  void set_absent_validators(int index, ::google::protobuf::int32 value);
  void add_absent_validators(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      absent_validators() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_absent_validators();

  // repeated .types.Evidence byzantine_validators = 4;
  int byzantine_validators_size() const;
  void clear_byzantine_validators();
  static const int kByzantineValidatorsFieldNumber = 4;
  const ::types::Evidence& byzantine_validators(int index) const;
  ::types::Evidence* mutable_byzantine_validators(int index);
  ::types::Evidence* add_byzantine_validators();
  ::google::protobuf::RepeatedPtrField< ::types::Evidence >*
      mutable_byzantine_validators();
  const ::google::protobuf::RepeatedPtrField< ::types::Evidence >&
      byzantine_validators() const;

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .types.Header header = 2;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::types::Header& header() const;
  ::types::Header* release_header();
  ::types::Header* mutable_header();
  void set_allocated_header(::types::Header* header);

  // @@protoc_insertion_point(class_scope:types.RequestBeginBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > absent_validators_;
  mutable int _absent_validators_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::types::Evidence > byzantine_validators_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::types::Header* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestBeginBlockImpl();
};
// -------------------------------------------------------------------

class RequestCheckTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestCheckTx) */ {
 public:
  RequestCheckTx();
  virtual ~RequestCheckTx();

  RequestCheckTx(const RequestCheckTx& from);

  inline RequestCheckTx& operator=(const RequestCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCheckTx(RequestCheckTx&& from) noexcept
    : RequestCheckTx() {
    *this = ::std::move(from);
  }

  inline RequestCheckTx& operator=(RequestCheckTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCheckTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCheckTx* internal_default_instance() {
    return reinterpret_cast<const RequestCheckTx*>(
               &_RequestCheckTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RequestCheckTx* other);
  friend void swap(RequestCheckTx& a, RequestCheckTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCheckTx* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestCheckTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestCheckTx& from);
  void MergeFrom(const RequestCheckTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestCheckTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx = 1;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::std::string& tx() const;
  void set_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_tx(::std::string&& value);
  #endif
  void set_tx(const char* value);
  void set_tx(const void* value, size_t size);
  ::std::string* mutable_tx();
  ::std::string* release_tx();
  void set_allocated_tx(::std::string* tx);

  // @@protoc_insertion_point(class_scope:types.RequestCheckTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestCheckTxImpl();
};
// -------------------------------------------------------------------

class RequestDeliverTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestDeliverTx) */ {
 public:
  RequestDeliverTx();
  virtual ~RequestDeliverTx();

  RequestDeliverTx(const RequestDeliverTx& from);

  inline RequestDeliverTx& operator=(const RequestDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestDeliverTx(RequestDeliverTx&& from) noexcept
    : RequestDeliverTx() {
    *this = ::std::move(from);
  }

  inline RequestDeliverTx& operator=(RequestDeliverTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestDeliverTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestDeliverTx* internal_default_instance() {
    return reinterpret_cast<const RequestDeliverTx*>(
               &_RequestDeliverTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RequestDeliverTx* other);
  friend void swap(RequestDeliverTx& a, RequestDeliverTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestDeliverTx* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestDeliverTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestDeliverTx& from);
  void MergeFrom(const RequestDeliverTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestDeliverTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx = 1;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::std::string& tx() const;
  void set_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_tx(::std::string&& value);
  #endif
  void set_tx(const char* value);
  void set_tx(const void* value, size_t size);
  ::std::string* mutable_tx();
  ::std::string* release_tx();
  void set_allocated_tx(::std::string* tx);

  // @@protoc_insertion_point(class_scope:types.RequestDeliverTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestDeliverTxImpl();
};
// -------------------------------------------------------------------

class RequestEndBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestEndBlock) */ {
 public:
  RequestEndBlock();
  virtual ~RequestEndBlock();

  RequestEndBlock(const RequestEndBlock& from);

  inline RequestEndBlock& operator=(const RequestEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestEndBlock(RequestEndBlock&& from) noexcept
    : RequestEndBlock() {
    *this = ::std::move(from);
  }

  inline RequestEndBlock& operator=(RequestEndBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestEndBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestEndBlock* internal_default_instance() {
    return reinterpret_cast<const RequestEndBlock*>(
               &_RequestEndBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RequestEndBlock* other);
  friend void swap(RequestEndBlock& a, RequestEndBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestEndBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestEndBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestEndBlock& from);
  void MergeFrom(const RequestEndBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestEndBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.RequestEndBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 height_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestEndBlockImpl();
};
// -------------------------------------------------------------------

class RequestCommit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestCommit) */ {
 public:
  RequestCommit();
  virtual ~RequestCommit();

  RequestCommit(const RequestCommit& from);

  inline RequestCommit& operator=(const RequestCommit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCommit(RequestCommit&& from) noexcept
    : RequestCommit() {
    *this = ::std::move(from);
  }

  inline RequestCommit& operator=(RequestCommit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCommit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCommit* internal_default_instance() {
    return reinterpret_cast<const RequestCommit*>(
               &_RequestCommit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(RequestCommit* other);
  friend void swap(RequestCommit& a, RequestCommit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCommit* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestCommit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestCommit& from);
  void MergeFrom(const RequestCommit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.RequestCommit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsRequestCommitImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ValueCase {
    kException = 1,
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 10,
    kEndBlock = 11,
    kCommit = 12,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.ResponseException exception = 1;
  bool has_exception() const;
  void clear_exception();
  static const int kExceptionFieldNumber = 1;
  const ::types::ResponseException& exception() const;
  ::types::ResponseException* release_exception();
  ::types::ResponseException* mutable_exception();
  void set_allocated_exception(::types::ResponseException* exception);

  // .types.ResponseEcho echo = 2;
  bool has_echo() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::types::ResponseEcho& echo() const;
  ::types::ResponseEcho* release_echo();
  ::types::ResponseEcho* mutable_echo();
  void set_allocated_echo(::types::ResponseEcho* echo);

  // .types.ResponseFlush flush = 3;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  const ::types::ResponseFlush& flush() const;
  ::types::ResponseFlush* release_flush();
  ::types::ResponseFlush* mutable_flush();
  void set_allocated_flush(::types::ResponseFlush* flush);

  // .types.ResponseInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::types::ResponseInfo& info() const;
  ::types::ResponseInfo* release_info();
  ::types::ResponseInfo* mutable_info();
  void set_allocated_info(::types::ResponseInfo* info);

  // .types.ResponseSetOption set_option = 5;
  bool has_set_option() const;
  void clear_set_option();
  static const int kSetOptionFieldNumber = 5;
  const ::types::ResponseSetOption& set_option() const;
  ::types::ResponseSetOption* release_set_option();
  ::types::ResponseSetOption* mutable_set_option();
  void set_allocated_set_option(::types::ResponseSetOption* set_option);

  // .types.ResponseInitChain init_chain = 6;
  bool has_init_chain() const;
  void clear_init_chain();
  static const int kInitChainFieldNumber = 6;
  const ::types::ResponseInitChain& init_chain() const;
  ::types::ResponseInitChain* release_init_chain();
  ::types::ResponseInitChain* mutable_init_chain();
  void set_allocated_init_chain(::types::ResponseInitChain* init_chain);

  // .types.ResponseQuery query = 7;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 7;
  const ::types::ResponseQuery& query() const;
  ::types::ResponseQuery* release_query();
  ::types::ResponseQuery* mutable_query();
  void set_allocated_query(::types::ResponseQuery* query);

  // .types.ResponseBeginBlock begin_block = 8;
  bool has_begin_block() const;
  void clear_begin_block();
  static const int kBeginBlockFieldNumber = 8;
  const ::types::ResponseBeginBlock& begin_block() const;
  ::types::ResponseBeginBlock* release_begin_block();
  ::types::ResponseBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::types::ResponseBeginBlock* begin_block);

  // .types.ResponseCheckTx check_tx = 9;
  bool has_check_tx() const;
  void clear_check_tx();
  static const int kCheckTxFieldNumber = 9;
  const ::types::ResponseCheckTx& check_tx() const;
  ::types::ResponseCheckTx* release_check_tx();
  ::types::ResponseCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::types::ResponseCheckTx* check_tx);

  // .types.ResponseDeliverTx deliver_tx = 10;
  bool has_deliver_tx() const;
  void clear_deliver_tx();
  static const int kDeliverTxFieldNumber = 10;
  const ::types::ResponseDeliverTx& deliver_tx() const;
  ::types::ResponseDeliverTx* release_deliver_tx();
  ::types::ResponseDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::types::ResponseDeliverTx* deliver_tx);

  // .types.ResponseEndBlock end_block = 11;
  bool has_end_block() const;
  void clear_end_block();
  static const int kEndBlockFieldNumber = 11;
  const ::types::ResponseEndBlock& end_block() const;
  ::types::ResponseEndBlock* release_end_block();
  ::types::ResponseEndBlock* mutable_end_block();
  void set_allocated_end_block(::types::ResponseEndBlock* end_block);

  // .types.ResponseCommit commit = 12;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 12;
  const ::types::ResponseCommit& commit() const;
  ::types::ResponseCommit* release_commit();
  ::types::ResponseCommit* mutable_commit();
  void set_allocated_commit(::types::ResponseCommit* commit);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:types.Response)
 private:
  void set_has_exception();
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::types::ResponseException* exception_;
    ::types::ResponseEcho* echo_;
    ::types::ResponseFlush* flush_;
    ::types::ResponseInfo* info_;
    ::types::ResponseSetOption* set_option_;
    ::types::ResponseInitChain* init_chain_;
    ::types::ResponseQuery* query_;
    ::types::ResponseBeginBlock* begin_block_;
    ::types::ResponseCheckTx* check_tx_;
    ::types::ResponseDeliverTx* deliver_tx_;
    ::types::ResponseEndBlock* end_block_;
    ::types::ResponseCommit* commit_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class ResponseException : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseException) */ {
 public:
  ResponseException();
  virtual ~ResponseException();

  ResponseException(const ResponseException& from);

  inline ResponseException& operator=(const ResponseException& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseException(ResponseException&& from) noexcept
    : ResponseException() {
    *this = ::std::move(from);
  }

  inline ResponseException& operator=(ResponseException&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseException& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseException* internal_default_instance() {
    return reinterpret_cast<const ResponseException*>(
               &_ResponseException_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ResponseException* other);
  friend void swap(ResponseException& a, ResponseException& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseException* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseException* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseException& from);
  void MergeFrom(const ResponseException& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseException* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:types.ResponseException)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseExceptionImpl();
};
// -------------------------------------------------------------------

class ResponseEcho : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseEcho) */ {
 public:
  ResponseEcho();
  virtual ~ResponseEcho();

  ResponseEcho(const ResponseEcho& from);

  inline ResponseEcho& operator=(const ResponseEcho& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseEcho(ResponseEcho&& from) noexcept
    : ResponseEcho() {
    *this = ::std::move(from);
  }

  inline ResponseEcho& operator=(ResponseEcho&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEcho& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseEcho* internal_default_instance() {
    return reinterpret_cast<const ResponseEcho*>(
               &_ResponseEcho_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ResponseEcho* other);
  friend void swap(ResponseEcho& a, ResponseEcho& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseEcho* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseEcho* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseEcho& from);
  void MergeFrom(const ResponseEcho& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:types.ResponseEcho)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseEchoImpl();
};
// -------------------------------------------------------------------

class ResponseFlush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseFlush) */ {
 public:
  ResponseFlush();
  virtual ~ResponseFlush();

  ResponseFlush(const ResponseFlush& from);

  inline ResponseFlush& operator=(const ResponseFlush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseFlush(ResponseFlush&& from) noexcept
    : ResponseFlush() {
    *this = ::std::move(from);
  }

  inline ResponseFlush& operator=(ResponseFlush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFlush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseFlush* internal_default_instance() {
    return reinterpret_cast<const ResponseFlush*>(
               &_ResponseFlush_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ResponseFlush* other);
  friend void swap(ResponseFlush& a, ResponseFlush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseFlush* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseFlush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseFlush& from);
  void MergeFrom(const ResponseFlush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseFlush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.ResponseFlush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseFlushImpl();
};
// -------------------------------------------------------------------

class ResponseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseInfo) */ {
 public:
  ResponseInfo();
  virtual ~ResponseInfo();

  ResponseInfo(const ResponseInfo& from);

  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseInfo(ResponseInfo&& from) noexcept
    : ResponseInfo() {
    *this = ::std::move(from);
  }

  inline ResponseInfo& operator=(ResponseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseInfo*>(
               &_ResponseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ResponseInfo* other);
  friend void swap(ResponseInfo& a, ResponseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseInfo& from);
  void MergeFrom(const ResponseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // bytes last_block_app_hash = 4;
  void clear_last_block_app_hash();
  static const int kLastBlockAppHashFieldNumber = 4;
  const ::std::string& last_block_app_hash() const;
  void set_last_block_app_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_block_app_hash(::std::string&& value);
  #endif
  void set_last_block_app_hash(const char* value);
  void set_last_block_app_hash(const void* value, size_t size);
  ::std::string* mutable_last_block_app_hash();
  ::std::string* release_last_block_app_hash();
  void set_allocated_last_block_app_hash(::std::string* last_block_app_hash);

  // int64 last_block_height = 3;
  void clear_last_block_height();
  static const int kLastBlockHeightFieldNumber = 3;
  ::google::protobuf::int64 last_block_height() const;
  void set_last_block_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.ResponseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr last_block_app_hash_;
  ::google::protobuf::int64 last_block_height_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseInfoImpl();
};
// -------------------------------------------------------------------

class ResponseSetOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseSetOption) */ {
 public:
  ResponseSetOption();
  virtual ~ResponseSetOption();

  ResponseSetOption(const ResponseSetOption& from);

  inline ResponseSetOption& operator=(const ResponseSetOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseSetOption(ResponseSetOption&& from) noexcept
    : ResponseSetOption() {
    *this = ::std::move(from);
  }

  inline ResponseSetOption& operator=(ResponseSetOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSetOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSetOption* internal_default_instance() {
    return reinterpret_cast<const ResponseSetOption*>(
               &_ResponseSetOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(ResponseSetOption* other);
  friend void swap(ResponseSetOption& a, ResponseSetOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseSetOption* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseSetOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseSetOption& from);
  void MergeFrom(const ResponseSetOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseSetOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseSetOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseSetOptionImpl();
};
// -------------------------------------------------------------------

class ResponseInitChain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseInitChain) */ {
 public:
  ResponseInitChain();
  virtual ~ResponseInitChain();

  ResponseInitChain(const ResponseInitChain& from);

  inline ResponseInitChain& operator=(const ResponseInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseInitChain(ResponseInitChain&& from) noexcept
    : ResponseInitChain() {
    *this = ::std::move(from);
  }

  inline ResponseInitChain& operator=(ResponseInitChain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseInitChain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseInitChain* internal_default_instance() {
    return reinterpret_cast<const ResponseInitChain*>(
               &_ResponseInitChain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ResponseInitChain* other);
  friend void swap(ResponseInitChain& a, ResponseInitChain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseInitChain* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseInitChain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseInitChain& from);
  void MergeFrom(const ResponseInitChain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseInitChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.ResponseInitChain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseInitChainImpl();
};
// -------------------------------------------------------------------

class ResponseQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseQuery) */ {
 public:
  ResponseQuery();
  virtual ~ResponseQuery();

  ResponseQuery(const ResponseQuery& from);

  inline ResponseQuery& operator=(const ResponseQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuery(ResponseQuery&& from) noexcept
    : ResponseQuery() {
    *this = ::std::move(from);
  }

  inline ResponseQuery& operator=(ResponseQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuery* internal_default_instance() {
    return reinterpret_cast<const ResponseQuery*>(
               &_ResponseQuery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(ResponseQuery* other);
  friend void swap(ResponseQuery& a, ResponseQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuery* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseQuery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseQuery& from);
  void MergeFrom(const ResponseQuery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // bytes key = 6;
  void clear_key();
  static const int kKeyFieldNumber = 6;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 7;
  void clear_value();
  static const int kValueFieldNumber = 7;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // bytes proof = 8;
  void clear_proof();
  static const int kProofFieldNumber = 8;
  const ::std::string& proof() const;
  void set_proof(const ::std::string& value);
  #if LANG_CXX11
  void set_proof(::std::string&& value);
  #endif
  void set_proof(const char* value);
  void set_proof(const void* value, size_t size);
  ::std::string* mutable_proof();
  ::std::string* release_proof();
  void set_allocated_proof(::std::string* proof);

  // int64 index = 5;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // int64 height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseQuery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr proof_;
  ::google::protobuf::int64 index_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseQueryImpl();
};
// -------------------------------------------------------------------

class ResponseBeginBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseBeginBlock) */ {
 public:
  ResponseBeginBlock();
  virtual ~ResponseBeginBlock();

  ResponseBeginBlock(const ResponseBeginBlock& from);

  inline ResponseBeginBlock& operator=(const ResponseBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseBeginBlock(ResponseBeginBlock&& from) noexcept
    : ResponseBeginBlock() {
    *this = ::std::move(from);
  }

  inline ResponseBeginBlock& operator=(ResponseBeginBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBeginBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseBeginBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseBeginBlock*>(
               &_ResponseBeginBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ResponseBeginBlock* other);
  friend void swap(ResponseBeginBlock& a, ResponseBeginBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseBeginBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseBeginBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseBeginBlock& from);
  void MergeFrom(const ResponseBeginBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseBeginBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.ResponseBeginBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseBeginBlockImpl();
};
// -------------------------------------------------------------------

class ResponseCheckTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseCheckTx) */ {
 public:
  ResponseCheckTx();
  virtual ~ResponseCheckTx();

  ResponseCheckTx(const ResponseCheckTx& from);

  inline ResponseCheckTx& operator=(const ResponseCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseCheckTx(ResponseCheckTx&& from) noexcept
    : ResponseCheckTx() {
    *this = ::std::move(from);
  }

  inline ResponseCheckTx& operator=(ResponseCheckTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCheckTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCheckTx* internal_default_instance() {
    return reinterpret_cast<const ResponseCheckTx*>(
               &_ResponseCheckTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ResponseCheckTx* other);
  friend void swap(ResponseCheckTx& a, ResponseCheckTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseCheckTx* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseCheckTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseCheckTx& from);
  void MergeFrom(const ResponseCheckTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseCheckTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.KVPair tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::types::KVPair& tags(int index) const;
  ::types::KVPair* mutable_tags(int index);
  ::types::KVPair* add_tags();
  ::google::protobuf::RepeatedPtrField< ::types::KVPair >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::types::KVPair >&
      tags() const;

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // .types.KI64Pair fee = 8;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 8;
  const ::types::KI64Pair& fee() const;
  ::types::KI64Pair* release_fee();
  ::types::KI64Pair* mutable_fee();
  void set_allocated_fee(::types::KI64Pair* fee);

  // int64 gas_wanted = 5;
  void clear_gas_wanted();
  static const int kGasWantedFieldNumber = 5;
  ::google::protobuf::int64 gas_wanted() const;
  void set_gas_wanted(::google::protobuf::int64 value);

  // int64 gas_used = 6;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 6;
  ::google::protobuf::int64 gas_used() const;
  void set_gas_used(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseCheckTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::KVPair > tags_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::types::KI64Pair* fee_;
  ::google::protobuf::int64 gas_wanted_;
  ::google::protobuf::int64 gas_used_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseCheckTxImpl();
};
// -------------------------------------------------------------------

class ResponseDeliverTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseDeliverTx) */ {
 public:
  ResponseDeliverTx();
  virtual ~ResponseDeliverTx();

  ResponseDeliverTx(const ResponseDeliverTx& from);

  inline ResponseDeliverTx& operator=(const ResponseDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseDeliverTx(ResponseDeliverTx&& from) noexcept
    : ResponseDeliverTx() {
    *this = ::std::move(from);
  }

  inline ResponseDeliverTx& operator=(ResponseDeliverTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseDeliverTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseDeliverTx* internal_default_instance() {
    return reinterpret_cast<const ResponseDeliverTx*>(
               &_ResponseDeliverTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(ResponseDeliverTx* other);
  friend void swap(ResponseDeliverTx& a, ResponseDeliverTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseDeliverTx* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseDeliverTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseDeliverTx& from);
  void MergeFrom(const ResponseDeliverTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseDeliverTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.KVPair tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::types::KVPair& tags(int index) const;
  ::types::KVPair* mutable_tags(int index);
  ::types::KVPair* add_tags();
  ::google::protobuf::RepeatedPtrField< ::types::KVPair >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::types::KVPair >&
      tags() const;

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // .types.KI64Pair fee = 8;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 8;
  const ::types::KI64Pair& fee() const;
  ::types::KI64Pair* release_fee();
  ::types::KI64Pair* mutable_fee();
  void set_allocated_fee(::types::KI64Pair* fee);

  // int64 gas_wanted = 5;
  void clear_gas_wanted();
  static const int kGasWantedFieldNumber = 5;
  ::google::protobuf::int64 gas_wanted() const;
  void set_gas_wanted(::google::protobuf::int64 value);

  // int64 gas_used = 6;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 6;
  ::google::protobuf::int64 gas_used() const;
  void set_gas_used(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseDeliverTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::KVPair > tags_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::types::KI64Pair* fee_;
  ::google::protobuf::int64 gas_wanted_;
  ::google::protobuf::int64 gas_used_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseDeliverTxImpl();
};
// -------------------------------------------------------------------

class ResponseEndBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseEndBlock) */ {
 public:
  ResponseEndBlock();
  virtual ~ResponseEndBlock();

  ResponseEndBlock(const ResponseEndBlock& from);

  inline ResponseEndBlock& operator=(const ResponseEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseEndBlock(ResponseEndBlock&& from) noexcept
    : ResponseEndBlock() {
    *this = ::std::move(from);
  }

  inline ResponseEndBlock& operator=(ResponseEndBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEndBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseEndBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseEndBlock*>(
               &_ResponseEndBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ResponseEndBlock* other);
  friend void swap(ResponseEndBlock& a, ResponseEndBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseEndBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseEndBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseEndBlock& from);
  void MergeFrom(const ResponseEndBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseEndBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.Validator validator_updates = 1;
  int validator_updates_size() const;
  void clear_validator_updates();
  static const int kValidatorUpdatesFieldNumber = 1;
  const ::types::Validator& validator_updates(int index) const;
  ::types::Validator* mutable_validator_updates(int index);
  ::types::Validator* add_validator_updates();
  ::google::protobuf::RepeatedPtrField< ::types::Validator >*
      mutable_validator_updates();
  const ::google::protobuf::RepeatedPtrField< ::types::Validator >&
      validator_updates() const;

  // .types.ConsensusParams consensus_param_updates = 2;
  bool has_consensus_param_updates() const;
  void clear_consensus_param_updates();
  static const int kConsensusParamUpdatesFieldNumber = 2;
  const ::types::ConsensusParams& consensus_param_updates() const;
  ::types::ConsensusParams* release_consensus_param_updates();
  ::types::ConsensusParams* mutable_consensus_param_updates();
  void set_allocated_consensus_param_updates(::types::ConsensusParams* consensus_param_updates);

  // @@protoc_insertion_point(class_scope:types.ResponseEndBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::Validator > validator_updates_;
  ::types::ConsensusParams* consensus_param_updates_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseEndBlockImpl();
};
// -------------------------------------------------------------------

class ResponseCommit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseCommit) */ {
 public:
  ResponseCommit();
  virtual ~ResponseCommit();

  ResponseCommit(const ResponseCommit& from);

  inline ResponseCommit& operator=(const ResponseCommit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseCommit(ResponseCommit&& from) noexcept
    : ResponseCommit() {
    *this = ::std::move(from);
  }

  inline ResponseCommit& operator=(ResponseCommit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCommit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCommit* internal_default_instance() {
    return reinterpret_cast<const ResponseCommit*>(
               &_ResponseCommit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ResponseCommit* other);
  friend void swap(ResponseCommit& a, ResponseCommit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseCommit* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseCommit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseCommit& from);
  void MergeFrom(const ResponseCommit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:types.ResponseCommit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsResponseCommitImpl();
};
// -------------------------------------------------------------------

class ConsensusParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ConsensusParams) */ {
 public:
  ConsensusParams();
  virtual ~ConsensusParams();

  ConsensusParams(const ConsensusParams& from);

  inline ConsensusParams& operator=(const ConsensusParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConsensusParams(ConsensusParams&& from) noexcept
    : ConsensusParams() {
    *this = ::std::move(from);
  }

  inline ConsensusParams& operator=(ConsensusParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsensusParams* internal_default_instance() {
    return reinterpret_cast<const ConsensusParams*>(
               &_ConsensusParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(ConsensusParams* other);
  friend void swap(ConsensusParams& a, ConsensusParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConsensusParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ConsensusParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConsensusParams& from);
  void MergeFrom(const ConsensusParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConsensusParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.BlockSize block_size = 1;
  bool has_block_size() const;
  void clear_block_size();
  static const int kBlockSizeFieldNumber = 1;
  const ::types::BlockSize& block_size() const;
  ::types::BlockSize* release_block_size();
  ::types::BlockSize* mutable_block_size();
  void set_allocated_block_size(::types::BlockSize* block_size);

  // .types.TxSize tx_size = 2;
  bool has_tx_size() const;
  void clear_tx_size();
  static const int kTxSizeFieldNumber = 2;
  const ::types::TxSize& tx_size() const;
  ::types::TxSize* release_tx_size();
  ::types::TxSize* mutable_tx_size();
  void set_allocated_tx_size(::types::TxSize* tx_size);

  // .types.BlockGossip block_gossip = 3;
  bool has_block_gossip() const;
  void clear_block_gossip();
  static const int kBlockGossipFieldNumber = 3;
  const ::types::BlockGossip& block_gossip() const;
  ::types::BlockGossip* release_block_gossip();
  ::types::BlockGossip* mutable_block_gossip();
  void set_allocated_block_gossip(::types::BlockGossip* block_gossip);

  // @@protoc_insertion_point(class_scope:types.ConsensusParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::BlockSize* block_size_;
  ::types::TxSize* tx_size_;
  ::types::BlockGossip* block_gossip_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsConsensusParamsImpl();
};
// -------------------------------------------------------------------

class BlockSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BlockSize) */ {
 public:
  BlockSize();
  virtual ~BlockSize();

  BlockSize(const BlockSize& from);

  inline BlockSize& operator=(const BlockSize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockSize(BlockSize&& from) noexcept
    : BlockSize() {
    *this = ::std::move(from);
  }

  inline BlockSize& operator=(BlockSize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockSize* internal_default_instance() {
    return reinterpret_cast<const BlockSize*>(
               &_BlockSize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(BlockSize* other);
  friend void swap(BlockSize& a, BlockSize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockSize* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockSize& from);
  void MergeFrom(const BlockSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 max_bytes = 1;
  void clear_max_bytes();
  static const int kMaxBytesFieldNumber = 1;
  ::google::protobuf::int32 max_bytes() const;
  void set_max_bytes(::google::protobuf::int32 value);

  // int32 max_txs = 2;
  void clear_max_txs();
  static const int kMaxTxsFieldNumber = 2;
  ::google::protobuf::int32 max_txs() const;
  void set_max_txs(::google::protobuf::int32 value);

  // int64 max_gas = 3;
  void clear_max_gas();
  static const int kMaxGasFieldNumber = 3;
  ::google::protobuf::int64 max_gas() const;
  void set_max_gas(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.BlockSize)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 max_bytes_;
  ::google::protobuf::int32 max_txs_;
  ::google::protobuf::int64 max_gas_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsBlockSizeImpl();
};
// -------------------------------------------------------------------

class TxSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.TxSize) */ {
 public:
  TxSize();
  virtual ~TxSize();

  TxSize(const TxSize& from);

  inline TxSize& operator=(const TxSize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxSize(TxSize&& from) noexcept
    : TxSize() {
    *this = ::std::move(from);
  }

  inline TxSize& operator=(TxSize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxSize* internal_default_instance() {
    return reinterpret_cast<const TxSize*>(
               &_TxSize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(TxSize* other);
  friend void swap(TxSize& a, TxSize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxSize* New() const PROTOBUF_FINAL { return New(NULL); }

  TxSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxSize& from);
  void MergeFrom(const TxSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 max_gas = 2;
  void clear_max_gas();
  static const int kMaxGasFieldNumber = 2;
  ::google::protobuf::int64 max_gas() const;
  void set_max_gas(::google::protobuf::int64 value);

  // int32 max_bytes = 1;
  void clear_max_bytes();
  static const int kMaxBytesFieldNumber = 1;
  ::google::protobuf::int32 max_bytes() const;
  void set_max_bytes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.TxSize)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 max_gas_;
  ::google::protobuf::int32 max_bytes_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsTxSizeImpl();
};
// -------------------------------------------------------------------

class BlockGossip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BlockGossip) */ {
 public:
  BlockGossip();
  virtual ~BlockGossip();

  BlockGossip(const BlockGossip& from);

  inline BlockGossip& operator=(const BlockGossip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockGossip(BlockGossip&& from) noexcept
    : BlockGossip() {
    *this = ::std::move(from);
  }

  inline BlockGossip& operator=(BlockGossip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockGossip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockGossip* internal_default_instance() {
    return reinterpret_cast<const BlockGossip*>(
               &_BlockGossip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(BlockGossip* other);
  friend void swap(BlockGossip& a, BlockGossip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockGossip* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockGossip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockGossip& from);
  void MergeFrom(const BlockGossip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockGossip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 block_part_size_bytes = 1;
  void clear_block_part_size_bytes();
  static const int kBlockPartSizeBytesFieldNumber = 1;
  ::google::protobuf::int32 block_part_size_bytes() const;
  void set_block_part_size_bytes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.BlockGossip)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 block_part_size_bytes_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsBlockGossipImpl();
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chain_id = 1;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 1;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // bytes last_commit_hash = 6;
  void clear_last_commit_hash();
  static const int kLastCommitHashFieldNumber = 6;
  const ::std::string& last_commit_hash() const;
  void set_last_commit_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_commit_hash(::std::string&& value);
  #endif
  void set_last_commit_hash(const char* value);
  void set_last_commit_hash(const void* value, size_t size);
  ::std::string* mutable_last_commit_hash();
  ::std::string* release_last_commit_hash();
  void set_allocated_last_commit_hash(::std::string* last_commit_hash);

  // bytes data_hash = 7;
  void clear_data_hash();
  static const int kDataHashFieldNumber = 7;
  const ::std::string& data_hash() const;
  void set_data_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_data_hash(::std::string&& value);
  #endif
  void set_data_hash(const char* value);
  void set_data_hash(const void* value, size_t size);
  ::std::string* mutable_data_hash();
  ::std::string* release_data_hash();
  void set_allocated_data_hash(::std::string* data_hash);

  // bytes validators_hash = 8;
  void clear_validators_hash();
  static const int kValidatorsHashFieldNumber = 8;
  const ::std::string& validators_hash() const;
  void set_validators_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_validators_hash(::std::string&& value);
  #endif
  void set_validators_hash(const char* value);
  void set_validators_hash(const void* value, size_t size);
  ::std::string* mutable_validators_hash();
  ::std::string* release_validators_hash();
  void set_allocated_validators_hash(::std::string* validators_hash);

  // bytes app_hash = 9;
  void clear_app_hash();
  static const int kAppHashFieldNumber = 9;
  const ::std::string& app_hash() const;
  void set_app_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_app_hash(::std::string&& value);
  #endif
  void set_app_hash(const char* value);
  void set_app_hash(const void* value, size_t size);
  ::std::string* mutable_app_hash();
  ::std::string* release_app_hash();
  void set_allocated_app_hash(::std::string* app_hash);

  // .types.BlockID last_block_id = 5;
  bool has_last_block_id() const;
  void clear_last_block_id();
  static const int kLastBlockIdFieldNumber = 5;
  const ::types::BlockID& last_block_id() const;
  ::types::BlockID* release_last_block_id();
  ::types::BlockID* mutable_last_block_id();
  void set_allocated_last_block_id(::types::BlockID* last_block_id);

  // int64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int64 time = 3;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // int32 num_txs = 4;
  void clear_num_txs();
  static const int kNumTxsFieldNumber = 4;
  ::google::protobuf::int32 num_txs() const;
  void set_num_txs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr last_commit_hash_;
  ::google::protobuf::internal::ArenaStringPtr data_hash_;
  ::google::protobuf::internal::ArenaStringPtr validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr app_hash_;
  ::types::BlockID* last_block_id_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 num_txs_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class BlockID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BlockID) */ {
 public:
  BlockID();
  virtual ~BlockID();

  BlockID(const BlockID& from);

  inline BlockID& operator=(const BlockID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockID(BlockID&& from) noexcept
    : BlockID() {
    *this = ::std::move(from);
  }

  inline BlockID& operator=(BlockID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockID* internal_default_instance() {
    return reinterpret_cast<const BlockID*>(
               &_BlockID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(BlockID* other);
  friend void swap(BlockID& a, BlockID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockID* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockID& from);
  void MergeFrom(const BlockID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .types.PartSetHeader parts = 2;
  bool has_parts() const;
  void clear_parts();
  static const int kPartsFieldNumber = 2;
  const ::types::PartSetHeader& parts() const;
  ::types::PartSetHeader* release_parts();
  ::types::PartSetHeader* mutable_parts();
  void set_allocated_parts(::types::PartSetHeader* parts);

  // @@protoc_insertion_point(class_scope:types.BlockID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::types::PartSetHeader* parts_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsBlockIDImpl();
};
// -------------------------------------------------------------------

class PartSetHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.PartSetHeader) */ {
 public:
  PartSetHeader();
  virtual ~PartSetHeader();

  PartSetHeader(const PartSetHeader& from);

  inline PartSetHeader& operator=(const PartSetHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartSetHeader(PartSetHeader&& from) noexcept
    : PartSetHeader() {
    *this = ::std::move(from);
  }

  inline PartSetHeader& operator=(PartSetHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartSetHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartSetHeader* internal_default_instance() {
    return reinterpret_cast<const PartSetHeader*>(
               &_PartSetHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(PartSetHeader* other);
  friend void swap(PartSetHeader& a, PartSetHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartSetHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  PartSetHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartSetHeader& from);
  void MergeFrom(const PartSetHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartSetHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int32 total = 1;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int32 total() const;
  void set_total(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.PartSetHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int32 total_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsPartSetHeaderImpl();
};
// -------------------------------------------------------------------

class Validator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Validator) */ {
 public:
  Validator();
  virtual ~Validator();

  Validator(const Validator& from);

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(Validator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Validator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Validator* other);
  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Validator* New() const PROTOBUF_FINAL { return New(NULL); }

  Validator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Validator& from);
  void MergeFrom(const Validator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Validator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pub_key = 1;
  void clear_pub_key();
  static const int kPubKeyFieldNumber = 1;
  const ::std::string& pub_key() const;
  void set_pub_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pub_key(::std::string&& value);
  #endif
  void set_pub_key(const char* value);
  void set_pub_key(const void* value, size_t size);
  ::std::string* mutable_pub_key();
  ::std::string* release_pub_key();
  void set_allocated_pub_key(::std::string* pub_key);

  // int64 power = 2;
  void clear_power();
  static const int kPowerFieldNumber = 2;
  ::google::protobuf::int64 power() const;
  void set_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.Validator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pub_key_;
  ::google::protobuf::int64 power_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsValidatorImpl();
};
// -------------------------------------------------------------------

class Evidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Evidence) */ {
 public:
  Evidence();
  virtual ~Evidence();

  Evidence(const Evidence& from);

  inline Evidence& operator=(const Evidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Evidence(Evidence&& from) noexcept
    : Evidence() {
    *this = ::std::move(from);
  }

  inline Evidence& operator=(Evidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Evidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Evidence* internal_default_instance() {
    return reinterpret_cast<const Evidence*>(
               &_Evidence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Evidence* other);
  friend void swap(Evidence& a, Evidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Evidence* New() const PROTOBUF_FINAL { return New(NULL); }

  Evidence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Evidence& from);
  void MergeFrom(const Evidence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Evidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pub_key = 1;
  void clear_pub_key();
  static const int kPubKeyFieldNumber = 1;
  const ::std::string& pub_key() const;
  void set_pub_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pub_key(::std::string&& value);
  #endif
  void set_pub_key(const char* value);
  void set_pub_key(const void* value, size_t size);
  ::std::string* mutable_pub_key();
  ::std::string* release_pub_key();
  void set_allocated_pub_key(::std::string* pub_key);

  // int64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.Evidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pub_key_;
  ::google::protobuf::int64 height_;
  mutable int _cached_size_;
  friend struct ::protobuf_types_2eproto::TableStruct;
  friend void ::protobuf_types_2eproto::InitDefaultsEvidenceImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KVPair

// bytes key = 1;
inline void KVPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KVPair::key() const {
  // @@protoc_insertion_point(field_get:types.KVPair.key)
  return key_.GetNoArena();
}
inline void KVPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.KVPair.key)
}
#if LANG_CXX11
inline void KVPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.KVPair.key)
}
#endif
inline void KVPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.KVPair.key)
}
inline void KVPair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.KVPair.key)
}
inline ::std::string* KVPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:types.KVPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KVPair::release_key() {
  // @@protoc_insertion_point(field_release:types.KVPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KVPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:types.KVPair.key)
}

// bytes value = 2;
inline void KVPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KVPair::value() const {
  // @@protoc_insertion_point(field_get:types.KVPair.value)
  return value_.GetNoArena();
}
inline void KVPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.KVPair.value)
}
#if LANG_CXX11
inline void KVPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.KVPair.value)
}
#endif
inline void KVPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.KVPair.value)
}
inline void KVPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.KVPair.value)
}
inline ::std::string* KVPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:types.KVPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KVPair::release_value() {
  // @@protoc_insertion_point(field_release:types.KVPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KVPair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.KVPair.value)
}

// -------------------------------------------------------------------

// KI64Pair

// bytes key = 1;
inline void KI64Pair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KI64Pair::key() const {
  // @@protoc_insertion_point(field_get:types.KI64Pair.key)
  return key_.GetNoArena();
}
inline void KI64Pair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.KI64Pair.key)
}
#if LANG_CXX11
inline void KI64Pair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.KI64Pair.key)
}
#endif
inline void KI64Pair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.KI64Pair.key)
}
inline void KI64Pair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.KI64Pair.key)
}
inline ::std::string* KI64Pair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:types.KI64Pair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KI64Pair::release_key() {
  // @@protoc_insertion_point(field_release:types.KI64Pair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KI64Pair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:types.KI64Pair.key)
}

// int64 value = 2;
inline void KI64Pair::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KI64Pair::value() const {
  // @@protoc_insertion_point(field_get:types.KI64Pair.value)
  return value_;
}
inline void KI64Pair::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:types.KI64Pair.value)
}

// -------------------------------------------------------------------

// Request

// .types.RequestEcho echo = 2;
inline bool Request::has_echo() const {
  return value_case() == kEcho;
}
inline void Request::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Request::clear_echo() {
  if (has_echo()) {
    delete value_.echo_;
    clear_has_value();
  }
}
inline ::types::RequestEcho* Request::release_echo() {
  // @@protoc_insertion_point(field_release:types.Request.echo)
  if (has_echo()) {
    clear_has_value();
      ::types::RequestEcho* temp = value_.echo_;
    value_.echo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestEcho& Request::echo() const {
  // @@protoc_insertion_point(field_get:types.Request.echo)
  return has_echo()
      ? *value_.echo_
      : *reinterpret_cast< ::types::RequestEcho*>(&::types::_RequestEcho_default_instance_);
}
inline ::types::RequestEcho* Request::mutable_echo() {
  if (!has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = new ::types::RequestEcho;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.echo)
  return value_.echo_;
}

// .types.RequestFlush flush = 3;
inline bool Request::has_flush() const {
  return value_case() == kFlush;
}
inline void Request::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Request::clear_flush() {
  if (has_flush()) {
    delete value_.flush_;
    clear_has_value();
  }
}
inline ::types::RequestFlush* Request::release_flush() {
  // @@protoc_insertion_point(field_release:types.Request.flush)
  if (has_flush()) {
    clear_has_value();
      ::types::RequestFlush* temp = value_.flush_;
    value_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestFlush& Request::flush() const {
  // @@protoc_insertion_point(field_get:types.Request.flush)
  return has_flush()
      ? *value_.flush_
      : *reinterpret_cast< ::types::RequestFlush*>(&::types::_RequestFlush_default_instance_);
}
inline ::types::RequestFlush* Request::mutable_flush() {
  if (!has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = new ::types::RequestFlush;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.flush)
  return value_.flush_;
}

// .types.RequestInfo info = 4;
inline bool Request::has_info() const {
  return value_case() == kInfo;
}
inline void Request::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (has_info()) {
    delete value_.info_;
    clear_has_value();
  }
}
inline ::types::RequestInfo* Request::release_info() {
  // @@protoc_insertion_point(field_release:types.Request.info)
  if (has_info()) {
    clear_has_value();
      ::types::RequestInfo* temp = value_.info_;
    value_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestInfo& Request::info() const {
  // @@protoc_insertion_point(field_get:types.Request.info)
  return has_info()
      ? *value_.info_
      : *reinterpret_cast< ::types::RequestInfo*>(&::types::_RequestInfo_default_instance_);
}
inline ::types::RequestInfo* Request::mutable_info() {
  if (!has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = new ::types::RequestInfo;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.info)
  return value_.info_;
}

// .types.RequestSetOption set_option = 5;
inline bool Request::has_set_option() const {
  return value_case() == kSetOption;
}
inline void Request::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Request::clear_set_option() {
  if (has_set_option()) {
    delete value_.set_option_;
    clear_has_value();
  }
}
inline ::types::RequestSetOption* Request::release_set_option() {
  // @@protoc_insertion_point(field_release:types.Request.set_option)
  if (has_set_option()) {
    clear_has_value();
      ::types::RequestSetOption* temp = value_.set_option_;
    value_.set_option_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestSetOption& Request::set_option() const {
  // @@protoc_insertion_point(field_get:types.Request.set_option)
  return has_set_option()
      ? *value_.set_option_
      : *reinterpret_cast< ::types::RequestSetOption*>(&::types::_RequestSetOption_default_instance_);
}
inline ::types::RequestSetOption* Request::mutable_set_option() {
  if (!has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = new ::types::RequestSetOption;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.set_option)
  return value_.set_option_;
}

// .types.RequestInitChain init_chain = 6;
inline bool Request::has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Request::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Request::clear_init_chain() {
  if (has_init_chain()) {
    delete value_.init_chain_;
    clear_has_value();
  }
}
inline ::types::RequestInitChain* Request::release_init_chain() {
  // @@protoc_insertion_point(field_release:types.Request.init_chain)
  if (has_init_chain()) {
    clear_has_value();
      ::types::RequestInitChain* temp = value_.init_chain_;
    value_.init_chain_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestInitChain& Request::init_chain() const {
  // @@protoc_insertion_point(field_get:types.Request.init_chain)
  return has_init_chain()
      ? *value_.init_chain_
      : *reinterpret_cast< ::types::RequestInitChain*>(&::types::_RequestInitChain_default_instance_);
}
inline ::types::RequestInitChain* Request::mutable_init_chain() {
  if (!has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = new ::types::RequestInitChain;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.init_chain)
  return value_.init_chain_;
}

// .types.RequestQuery query = 7;
inline bool Request::has_query() const {
  return value_case() == kQuery;
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Request::clear_query() {
  if (has_query()) {
    delete value_.query_;
    clear_has_value();
  }
}
inline ::types::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:types.Request.query)
  if (has_query()) {
    clear_has_value();
      ::types::RequestQuery* temp = value_.query_;
    value_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:types.Request.query)
  return has_query()
      ? *value_.query_
      : *reinterpret_cast< ::types::RequestQuery*>(&::types::_RequestQuery_default_instance_);
}
inline ::types::RequestQuery* Request::mutable_query() {
  if (!has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = new ::types::RequestQuery;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.query)
  return value_.query_;
}

// .types.RequestBeginBlock begin_block = 8;
inline bool Request::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Request::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Request::clear_begin_block() {
  if (has_begin_block()) {
    delete value_.begin_block_;
    clear_has_value();
  }
}
inline ::types::RequestBeginBlock* Request::release_begin_block() {
  // @@protoc_insertion_point(field_release:types.Request.begin_block)
  if (has_begin_block()) {
    clear_has_value();
      ::types::RequestBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestBeginBlock& Request::begin_block() const {
  // @@protoc_insertion_point(field_get:types.Request.begin_block)
  return has_begin_block()
      ? *value_.begin_block_
      : *reinterpret_cast< ::types::RequestBeginBlock*>(&::types::_RequestBeginBlock_default_instance_);
}
inline ::types::RequestBeginBlock* Request::mutable_begin_block() {
  if (!has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = new ::types::RequestBeginBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.begin_block)
  return value_.begin_block_;
}

// .types.RequestCheckTx check_tx = 9;
inline bool Request::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Request::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Request::clear_check_tx() {
  if (has_check_tx()) {
    delete value_.check_tx_;
    clear_has_value();
  }
}
inline ::types::RequestCheckTx* Request::release_check_tx() {
  // @@protoc_insertion_point(field_release:types.Request.check_tx)
  if (has_check_tx()) {
    clear_has_value();
      ::types::RequestCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestCheckTx& Request::check_tx() const {
  // @@protoc_insertion_point(field_get:types.Request.check_tx)
  return has_check_tx()
      ? *value_.check_tx_
      : *reinterpret_cast< ::types::RequestCheckTx*>(&::types::_RequestCheckTx_default_instance_);
}
inline ::types::RequestCheckTx* Request::mutable_check_tx() {
  if (!has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = new ::types::RequestCheckTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.check_tx)
  return value_.check_tx_;
}

// .types.RequestDeliverTx deliver_tx = 19;
inline bool Request::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Request::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Request::clear_deliver_tx() {
  if (has_deliver_tx()) {
    delete value_.deliver_tx_;
    clear_has_value();
  }
}
inline ::types::RequestDeliverTx* Request::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:types.Request.deliver_tx)
  if (has_deliver_tx()) {
    clear_has_value();
      ::types::RequestDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestDeliverTx& Request::deliver_tx() const {
  // @@protoc_insertion_point(field_get:types.Request.deliver_tx)
  return has_deliver_tx()
      ? *value_.deliver_tx_
      : *reinterpret_cast< ::types::RequestDeliverTx*>(&::types::_RequestDeliverTx_default_instance_);
}
inline ::types::RequestDeliverTx* Request::mutable_deliver_tx() {
  if (!has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = new ::types::RequestDeliverTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.deliver_tx)
  return value_.deliver_tx_;
}

// .types.RequestEndBlock end_block = 11;
inline bool Request::has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Request::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Request::clear_end_block() {
  if (has_end_block()) {
    delete value_.end_block_;
    clear_has_value();
  }
}
inline ::types::RequestEndBlock* Request::release_end_block() {
  // @@protoc_insertion_point(field_release:types.Request.end_block)
  if (has_end_block()) {
    clear_has_value();
      ::types::RequestEndBlock* temp = value_.end_block_;
    value_.end_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestEndBlock& Request::end_block() const {
  // @@protoc_insertion_point(field_get:types.Request.end_block)
  return has_end_block()
      ? *value_.end_block_
      : *reinterpret_cast< ::types::RequestEndBlock*>(&::types::_RequestEndBlock_default_instance_);
}
inline ::types::RequestEndBlock* Request::mutable_end_block() {
  if (!has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = new ::types::RequestEndBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.end_block)
  return value_.end_block_;
}

// .types.RequestCommit commit = 12;
inline bool Request::has_commit() const {
  return value_case() == kCommit;
}
inline void Request::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Request::clear_commit() {
  if (has_commit()) {
    delete value_.commit_;
    clear_has_value();
  }
}
inline ::types::RequestCommit* Request::release_commit() {
  // @@protoc_insertion_point(field_release:types.Request.commit)
  if (has_commit()) {
    clear_has_value();
      ::types::RequestCommit* temp = value_.commit_;
    value_.commit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::RequestCommit& Request::commit() const {
  // @@protoc_insertion_point(field_get:types.Request.commit)
  return has_commit()
      ? *value_.commit_
      : *reinterpret_cast< ::types::RequestCommit*>(&::types::_RequestCommit_default_instance_);
}
inline ::types::RequestCommit* Request::mutable_commit() {
  if (!has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = new ::types::RequestCommit;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.commit)
  return value_.commit_;
}

inline bool Request::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Request::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Request::ValueCase Request::value_case() const {
  return Request::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestEcho

// string message = 1;
inline void RequestEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestEcho::message() const {
  // @@protoc_insertion_point(field_get:types.RequestEcho.message)
  return message_.GetNoArena();
}
inline void RequestEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestEcho.message)
}
#if LANG_CXX11
inline void RequestEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestEcho.message)
}
#endif
inline void RequestEcho::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestEcho.message)
}
inline void RequestEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestEcho.message)
}
inline ::std::string* RequestEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestEcho::release_message() {
  // @@protoc_insertion_point(field_release:types.RequestEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestEcho::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:types.RequestEcho.message)
}

// -------------------------------------------------------------------

// RequestFlush

// -------------------------------------------------------------------

// RequestInfo

// string version = 1;
inline void RequestInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInfo::version() const {
  // @@protoc_insertion_point(field_get:types.RequestInfo.version)
  return version_.GetNoArena();
}
inline void RequestInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestInfo.version)
}
#if LANG_CXX11
inline void RequestInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestInfo.version)
}
#endif
inline void RequestInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestInfo.version)
}
inline void RequestInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestInfo.version)
}
inline ::std::string* RequestInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInfo::release_version() {
  // @@protoc_insertion_point(field_release:types.RequestInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:types.RequestInfo.version)
}

// -------------------------------------------------------------------

// RequestSetOption

// string key = 1;
inline void RequestSetOption::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestSetOption::key() const {
  // @@protoc_insertion_point(field_get:types.RequestSetOption.key)
  return key_.GetNoArena();
}
inline void RequestSetOption::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestSetOption.key)
}
#if LANG_CXX11
inline void RequestSetOption::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestSetOption.key)
}
#endif
inline void RequestSetOption::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestSetOption.key)
}
inline void RequestSetOption::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestSetOption.key)
}
inline ::std::string* RequestSetOption::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestSetOption.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSetOption::release_key() {
  // @@protoc_insertion_point(field_release:types.RequestSetOption.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSetOption::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:types.RequestSetOption.key)
}

// string value = 2;
inline void RequestSetOption::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestSetOption::value() const {
  // @@protoc_insertion_point(field_get:types.RequestSetOption.value)
  return value_.GetNoArena();
}
inline void RequestSetOption::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestSetOption.value)
}
#if LANG_CXX11
inline void RequestSetOption::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestSetOption.value)
}
#endif
inline void RequestSetOption::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestSetOption.value)
}
inline void RequestSetOption::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestSetOption.value)
}
inline ::std::string* RequestSetOption::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestSetOption.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSetOption::release_value() {
  // @@protoc_insertion_point(field_release:types.RequestSetOption.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSetOption::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.RequestSetOption.value)
}

// -------------------------------------------------------------------

// RequestInitChain

// repeated .types.Validator validators = 1;
inline int RequestInitChain::validators_size() const {
  return validators_.size();
}
inline void RequestInitChain::clear_validators() {
  validators_.Clear();
}
inline const ::types::Validator& RequestInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.validators)
  return validators_.Get(index);
}
inline ::types::Validator* RequestInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.validators)
  return validators_.Mutable(index);
}
inline ::types::Validator* RequestInitChain::add_validators() {
  // @@protoc_insertion_point(field_add:types.RequestInitChain.validators)
  return validators_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::Validator >*
RequestInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:types.RequestInitChain.validators)
  return &validators_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Validator >&
RequestInitChain::validators() const {
  // @@protoc_insertion_point(field_list:types.RequestInitChain.validators)
  return validators_;
}

// bytes app_state_bytes = 2;
inline void RequestInitChain::clear_app_state_bytes() {
  app_state_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInitChain::app_state_bytes() const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.app_state_bytes)
  return app_state_bytes_.GetNoArena();
}
inline void RequestInitChain::set_app_state_bytes(const ::std::string& value) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestInitChain.app_state_bytes)
}
#if LANG_CXX11
inline void RequestInitChain::set_app_state_bytes(::std::string&& value) {
  
  app_state_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestInitChain.app_state_bytes)
}
#endif
inline void RequestInitChain::set_app_state_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestInitChain.app_state_bytes)
}
inline void RequestInitChain::set_app_state_bytes(const void* value, size_t size) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestInitChain.app_state_bytes)
}
inline ::std::string* RequestInitChain::mutable_app_state_bytes() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.app_state_bytes)
  return app_state_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInitChain::release_app_state_bytes() {
  // @@protoc_insertion_point(field_release:types.RequestInitChain.app_state_bytes)
  
  return app_state_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInitChain::set_allocated_app_state_bytes(::std::string* app_state_bytes) {
  if (app_state_bytes != NULL) {
    
  } else {
    
  }
  app_state_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_state_bytes);
  // @@protoc_insertion_point(field_set_allocated:types.RequestInitChain.app_state_bytes)
}

// -------------------------------------------------------------------

// RequestQuery

// bytes data = 1;
inline void RequestQuery::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestQuery::data() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.data)
  return data_.GetNoArena();
}
inline void RequestQuery::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestQuery.data)
}
#if LANG_CXX11
inline void RequestQuery::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestQuery.data)
}
#endif
inline void RequestQuery::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestQuery.data)
}
inline void RequestQuery::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestQuery.data)
}
inline ::std::string* RequestQuery::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestQuery.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestQuery::release_data() {
  // @@protoc_insertion_point(field_release:types.RequestQuery.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestQuery::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.RequestQuery.data)
}

// string path = 2;
inline void RequestQuery::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestQuery::path() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.path)
  return path_.GetNoArena();
}
inline void RequestQuery::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestQuery.path)
}
#if LANG_CXX11
inline void RequestQuery::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestQuery.path)
}
#endif
inline void RequestQuery::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestQuery.path)
}
inline void RequestQuery::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestQuery.path)
}
inline ::std::string* RequestQuery::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestQuery.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestQuery::release_path() {
  // @@protoc_insertion_point(field_release:types.RequestQuery.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestQuery::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:types.RequestQuery.path)
}

// int64 height = 3;
inline void RequestQuery::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestQuery::height() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.height)
  return height_;
}
inline void RequestQuery::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.RequestQuery.height)
}

// bool prove = 4;
inline void RequestQuery::clear_prove() {
  prove_ = false;
}
inline bool RequestQuery::prove() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.prove)
  return prove_;
}
inline void RequestQuery::set_prove(bool value) {
  
  prove_ = value;
  // @@protoc_insertion_point(field_set:types.RequestQuery.prove)
}

// -------------------------------------------------------------------

// RequestBeginBlock

// bytes hash = 1;
inline void RequestBeginBlock::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestBeginBlock::hash() const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.hash)
  return hash_.GetNoArena();
}
inline void RequestBeginBlock::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestBeginBlock.hash)
}
#if LANG_CXX11
inline void RequestBeginBlock::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestBeginBlock.hash)
}
#endif
inline void RequestBeginBlock::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestBeginBlock.hash)
}
inline void RequestBeginBlock::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestBeginBlock.hash)
}
inline ::std::string* RequestBeginBlock::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestBeginBlock::release_hash() {
  // @@protoc_insertion_point(field_release:types.RequestBeginBlock.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestBeginBlock::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:types.RequestBeginBlock.hash)
}

// .types.Header header = 2;
inline bool RequestBeginBlock::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RequestBeginBlock::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::types::Header& RequestBeginBlock::header() const {
  const ::types::Header* p = header_;
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.header)
  return p != NULL ? *p : *reinterpret_cast<const ::types::Header*>(
      &::types::_Header_default_instance_);
}
inline ::types::Header* RequestBeginBlock::release_header() {
  // @@protoc_insertion_point(field_release:types.RequestBeginBlock.header)
  
  ::types::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::types::Header* RequestBeginBlock::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::types::Header;
  }
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.header)
  return header_;
}
inline void RequestBeginBlock::set_allocated_header(::types::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:types.RequestBeginBlock.header)
}

// repeated int32 absent_validators = 3;
inline int RequestBeginBlock::absent_validators_size() const {
  return absent_validators_.size();
}
inline void RequestBeginBlock::clear_absent_validators() {
  absent_validators_.Clear();
}
inline ::google::protobuf::int32 RequestBeginBlock::absent_validators(int index) const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.absent_validators)
  return absent_validators_.Get(index);
}
inline void RequestBeginBlock::set_absent_validators(int index, ::google::protobuf::int32 value) {
  absent_validators_.Set(index, value);
  // @@protoc_insertion_point(field_set:types.RequestBeginBlock.absent_validators)
}
inline void RequestBeginBlock::add_absent_validators(::google::protobuf::int32 value) {
  absent_validators_.Add(value);
  // @@protoc_insertion_point(field_add:types.RequestBeginBlock.absent_validators)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestBeginBlock::absent_validators() const {
  // @@protoc_insertion_point(field_list:types.RequestBeginBlock.absent_validators)
  return absent_validators_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestBeginBlock::mutable_absent_validators() {
  // @@protoc_insertion_point(field_mutable_list:types.RequestBeginBlock.absent_validators)
  return &absent_validators_;
}

// repeated .types.Evidence byzantine_validators = 4;
inline int RequestBeginBlock::byzantine_validators_size() const {
  return byzantine_validators_.size();
}
inline void RequestBeginBlock::clear_byzantine_validators() {
  byzantine_validators_.Clear();
}
inline const ::types::Evidence& RequestBeginBlock::byzantine_validators(int index) const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Get(index);
}
inline ::types::Evidence* RequestBeginBlock::mutable_byzantine_validators(int index) {
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Mutable(index);
}
inline ::types::Evidence* RequestBeginBlock::add_byzantine_validators() {
  // @@protoc_insertion_point(field_add:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::Evidence >*
RequestBeginBlock::mutable_byzantine_validators() {
  // @@protoc_insertion_point(field_mutable_list:types.RequestBeginBlock.byzantine_validators)
  return &byzantine_validators_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Evidence >&
RequestBeginBlock::byzantine_validators() const {
  // @@protoc_insertion_point(field_list:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_;
}

// -------------------------------------------------------------------

// RequestCheckTx

// bytes tx = 1;
inline void RequestCheckTx::clear_tx() {
  tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestCheckTx::tx() const {
  // @@protoc_insertion_point(field_get:types.RequestCheckTx.tx)
  return tx_.GetNoArena();
}
inline void RequestCheckTx::set_tx(const ::std::string& value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestCheckTx.tx)
}
#if LANG_CXX11
inline void RequestCheckTx::set_tx(::std::string&& value) {
  
  tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestCheckTx.tx)
}
#endif
inline void RequestCheckTx::set_tx(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestCheckTx.tx)
}
inline void RequestCheckTx::set_tx(const void* value, size_t size) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestCheckTx.tx)
}
inline ::std::string* RequestCheckTx::mutable_tx() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestCheckTx.tx)
  return tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCheckTx::release_tx() {
  // @@protoc_insertion_point(field_release:types.RequestCheckTx.tx)
  
  return tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCheckTx::set_allocated_tx(::std::string* tx) {
  if (tx != NULL) {
    
  } else {
    
  }
  tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx);
  // @@protoc_insertion_point(field_set_allocated:types.RequestCheckTx.tx)
}

// -------------------------------------------------------------------

// RequestDeliverTx

// bytes tx = 1;
inline void RequestDeliverTx::clear_tx() {
  tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestDeliverTx::tx() const {
  // @@protoc_insertion_point(field_get:types.RequestDeliverTx.tx)
  return tx_.GetNoArena();
}
inline void RequestDeliverTx::set_tx(const ::std::string& value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestDeliverTx.tx)
}
#if LANG_CXX11
inline void RequestDeliverTx::set_tx(::std::string&& value) {
  
  tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestDeliverTx.tx)
}
#endif
inline void RequestDeliverTx::set_tx(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestDeliverTx.tx)
}
inline void RequestDeliverTx::set_tx(const void* value, size_t size) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestDeliverTx.tx)
}
inline ::std::string* RequestDeliverTx::mutable_tx() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestDeliverTx.tx)
  return tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestDeliverTx::release_tx() {
  // @@protoc_insertion_point(field_release:types.RequestDeliverTx.tx)
  
  return tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestDeliverTx::set_allocated_tx(::std::string* tx) {
  if (tx != NULL) {
    
  } else {
    
  }
  tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx);
  // @@protoc_insertion_point(field_set_allocated:types.RequestDeliverTx.tx)
}

// -------------------------------------------------------------------

// RequestEndBlock

// int64 height = 1;
inline void RequestEndBlock::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestEndBlock::height() const {
  // @@protoc_insertion_point(field_get:types.RequestEndBlock.height)
  return height_;
}
inline void RequestEndBlock::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.RequestEndBlock.height)
}

// -------------------------------------------------------------------

// RequestCommit

// -------------------------------------------------------------------

// Response

// .types.ResponseException exception = 1;
inline bool Response::has_exception() const {
  return value_case() == kException;
}
inline void Response::set_has_exception() {
  _oneof_case_[0] = kException;
}
inline void Response::clear_exception() {
  if (has_exception()) {
    delete value_.exception_;
    clear_has_value();
  }
}
inline ::types::ResponseException* Response::release_exception() {
  // @@protoc_insertion_point(field_release:types.Response.exception)
  if (has_exception()) {
    clear_has_value();
      ::types::ResponseException* temp = value_.exception_;
    value_.exception_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseException& Response::exception() const {
  // @@protoc_insertion_point(field_get:types.Response.exception)
  return has_exception()
      ? *value_.exception_
      : *reinterpret_cast< ::types::ResponseException*>(&::types::_ResponseException_default_instance_);
}
inline ::types::ResponseException* Response::mutable_exception() {
  if (!has_exception()) {
    clear_value();
    set_has_exception();
    value_.exception_ = new ::types::ResponseException;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.exception)
  return value_.exception_;
}

// .types.ResponseEcho echo = 2;
inline bool Response::has_echo() const {
  return value_case() == kEcho;
}
inline void Response::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Response::clear_echo() {
  if (has_echo()) {
    delete value_.echo_;
    clear_has_value();
  }
}
inline ::types::ResponseEcho* Response::release_echo() {
  // @@protoc_insertion_point(field_release:types.Response.echo)
  if (has_echo()) {
    clear_has_value();
      ::types::ResponseEcho* temp = value_.echo_;
    value_.echo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseEcho& Response::echo() const {
  // @@protoc_insertion_point(field_get:types.Response.echo)
  return has_echo()
      ? *value_.echo_
      : *reinterpret_cast< ::types::ResponseEcho*>(&::types::_ResponseEcho_default_instance_);
}
inline ::types::ResponseEcho* Response::mutable_echo() {
  if (!has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = new ::types::ResponseEcho;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.echo)
  return value_.echo_;
}

// .types.ResponseFlush flush = 3;
inline bool Response::has_flush() const {
  return value_case() == kFlush;
}
inline void Response::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Response::clear_flush() {
  if (has_flush()) {
    delete value_.flush_;
    clear_has_value();
  }
}
inline ::types::ResponseFlush* Response::release_flush() {
  // @@protoc_insertion_point(field_release:types.Response.flush)
  if (has_flush()) {
    clear_has_value();
      ::types::ResponseFlush* temp = value_.flush_;
    value_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseFlush& Response::flush() const {
  // @@protoc_insertion_point(field_get:types.Response.flush)
  return has_flush()
      ? *value_.flush_
      : *reinterpret_cast< ::types::ResponseFlush*>(&::types::_ResponseFlush_default_instance_);
}
inline ::types::ResponseFlush* Response::mutable_flush() {
  if (!has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = new ::types::ResponseFlush;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.flush)
  return value_.flush_;
}

// .types.ResponseInfo info = 4;
inline bool Response::has_info() const {
  return value_case() == kInfo;
}
inline void Response::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Response::clear_info() {
  if (has_info()) {
    delete value_.info_;
    clear_has_value();
  }
}
inline ::types::ResponseInfo* Response::release_info() {
  // @@protoc_insertion_point(field_release:types.Response.info)
  if (has_info()) {
    clear_has_value();
      ::types::ResponseInfo* temp = value_.info_;
    value_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseInfo& Response::info() const {
  // @@protoc_insertion_point(field_get:types.Response.info)
  return has_info()
      ? *value_.info_
      : *reinterpret_cast< ::types::ResponseInfo*>(&::types::_ResponseInfo_default_instance_);
}
inline ::types::ResponseInfo* Response::mutable_info() {
  if (!has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = new ::types::ResponseInfo;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.info)
  return value_.info_;
}

// .types.ResponseSetOption set_option = 5;
inline bool Response::has_set_option() const {
  return value_case() == kSetOption;
}
inline void Response::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Response::clear_set_option() {
  if (has_set_option()) {
    delete value_.set_option_;
    clear_has_value();
  }
}
inline ::types::ResponseSetOption* Response::release_set_option() {
  // @@protoc_insertion_point(field_release:types.Response.set_option)
  if (has_set_option()) {
    clear_has_value();
      ::types::ResponseSetOption* temp = value_.set_option_;
    value_.set_option_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseSetOption& Response::set_option() const {
  // @@protoc_insertion_point(field_get:types.Response.set_option)
  return has_set_option()
      ? *value_.set_option_
      : *reinterpret_cast< ::types::ResponseSetOption*>(&::types::_ResponseSetOption_default_instance_);
}
inline ::types::ResponseSetOption* Response::mutable_set_option() {
  if (!has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = new ::types::ResponseSetOption;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.set_option)
  return value_.set_option_;
}

// .types.ResponseInitChain init_chain = 6;
inline bool Response::has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Response::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Response::clear_init_chain() {
  if (has_init_chain()) {
    delete value_.init_chain_;
    clear_has_value();
  }
}
inline ::types::ResponseInitChain* Response::release_init_chain() {
  // @@protoc_insertion_point(field_release:types.Response.init_chain)
  if (has_init_chain()) {
    clear_has_value();
      ::types::ResponseInitChain* temp = value_.init_chain_;
    value_.init_chain_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseInitChain& Response::init_chain() const {
  // @@protoc_insertion_point(field_get:types.Response.init_chain)
  return has_init_chain()
      ? *value_.init_chain_
      : *reinterpret_cast< ::types::ResponseInitChain*>(&::types::_ResponseInitChain_default_instance_);
}
inline ::types::ResponseInitChain* Response::mutable_init_chain() {
  if (!has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = new ::types::ResponseInitChain;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.init_chain)
  return value_.init_chain_;
}

// .types.ResponseQuery query = 7;
inline bool Response::has_query() const {
  return value_case() == kQuery;
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Response::clear_query() {
  if (has_query()) {
    delete value_.query_;
    clear_has_value();
  }
}
inline ::types::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:types.Response.query)
  if (has_query()) {
    clear_has_value();
      ::types::ResponseQuery* temp = value_.query_;
    value_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:types.Response.query)
  return has_query()
      ? *value_.query_
      : *reinterpret_cast< ::types::ResponseQuery*>(&::types::_ResponseQuery_default_instance_);
}
inline ::types::ResponseQuery* Response::mutable_query() {
  if (!has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = new ::types::ResponseQuery;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.query)
  return value_.query_;
}

// .types.ResponseBeginBlock begin_block = 8;
inline bool Response::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Response::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Response::clear_begin_block() {
  if (has_begin_block()) {
    delete value_.begin_block_;
    clear_has_value();
  }
}
inline ::types::ResponseBeginBlock* Response::release_begin_block() {
  // @@protoc_insertion_point(field_release:types.Response.begin_block)
  if (has_begin_block()) {
    clear_has_value();
      ::types::ResponseBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseBeginBlock& Response::begin_block() const {
  // @@protoc_insertion_point(field_get:types.Response.begin_block)
  return has_begin_block()
      ? *value_.begin_block_
      : *reinterpret_cast< ::types::ResponseBeginBlock*>(&::types::_ResponseBeginBlock_default_instance_);
}
inline ::types::ResponseBeginBlock* Response::mutable_begin_block() {
  if (!has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = new ::types::ResponseBeginBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.begin_block)
  return value_.begin_block_;
}

// .types.ResponseCheckTx check_tx = 9;
inline bool Response::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Response::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Response::clear_check_tx() {
  if (has_check_tx()) {
    delete value_.check_tx_;
    clear_has_value();
  }
}
inline ::types::ResponseCheckTx* Response::release_check_tx() {
  // @@protoc_insertion_point(field_release:types.Response.check_tx)
  if (has_check_tx()) {
    clear_has_value();
      ::types::ResponseCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseCheckTx& Response::check_tx() const {
  // @@protoc_insertion_point(field_get:types.Response.check_tx)
  return has_check_tx()
      ? *value_.check_tx_
      : *reinterpret_cast< ::types::ResponseCheckTx*>(&::types::_ResponseCheckTx_default_instance_);
}
inline ::types::ResponseCheckTx* Response::mutable_check_tx() {
  if (!has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = new ::types::ResponseCheckTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.check_tx)
  return value_.check_tx_;
}

// .types.ResponseDeliverTx deliver_tx = 10;
inline bool Response::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Response::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Response::clear_deliver_tx() {
  if (has_deliver_tx()) {
    delete value_.deliver_tx_;
    clear_has_value();
  }
}
inline ::types::ResponseDeliverTx* Response::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:types.Response.deliver_tx)
  if (has_deliver_tx()) {
    clear_has_value();
      ::types::ResponseDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseDeliverTx& Response::deliver_tx() const {
  // @@protoc_insertion_point(field_get:types.Response.deliver_tx)
  return has_deliver_tx()
      ? *value_.deliver_tx_
      : *reinterpret_cast< ::types::ResponseDeliverTx*>(&::types::_ResponseDeliverTx_default_instance_);
}
inline ::types::ResponseDeliverTx* Response::mutable_deliver_tx() {
  if (!has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = new ::types::ResponseDeliverTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.deliver_tx)
  return value_.deliver_tx_;
}

// .types.ResponseEndBlock end_block = 11;
inline bool Response::has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Response::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Response::clear_end_block() {
  if (has_end_block()) {
    delete value_.end_block_;
    clear_has_value();
  }
}
inline ::types::ResponseEndBlock* Response::release_end_block() {
  // @@protoc_insertion_point(field_release:types.Response.end_block)
  if (has_end_block()) {
    clear_has_value();
      ::types::ResponseEndBlock* temp = value_.end_block_;
    value_.end_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseEndBlock& Response::end_block() const {
  // @@protoc_insertion_point(field_get:types.Response.end_block)
  return has_end_block()
      ? *value_.end_block_
      : *reinterpret_cast< ::types::ResponseEndBlock*>(&::types::_ResponseEndBlock_default_instance_);
}
inline ::types::ResponseEndBlock* Response::mutable_end_block() {
  if (!has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = new ::types::ResponseEndBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.end_block)
  return value_.end_block_;
}

// .types.ResponseCommit commit = 12;
inline bool Response::has_commit() const {
  return value_case() == kCommit;
}
inline void Response::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Response::clear_commit() {
  if (has_commit()) {
    delete value_.commit_;
    clear_has_value();
  }
}
inline ::types::ResponseCommit* Response::release_commit() {
  // @@protoc_insertion_point(field_release:types.Response.commit)
  if (has_commit()) {
    clear_has_value();
      ::types::ResponseCommit* temp = value_.commit_;
    value_.commit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::types::ResponseCommit& Response::commit() const {
  // @@protoc_insertion_point(field_get:types.Response.commit)
  return has_commit()
      ? *value_.commit_
      : *reinterpret_cast< ::types::ResponseCommit*>(&::types::_ResponseCommit_default_instance_);
}
inline ::types::ResponseCommit* Response::mutable_commit() {
  if (!has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = new ::types::ResponseCommit;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.commit)
  return value_.commit_;
}

inline bool Response::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Response::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Response::ValueCase Response::value_case() const {
  return Response::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseException

// string error = 1;
inline void ResponseException::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseException::error() const {
  // @@protoc_insertion_point(field_get:types.ResponseException.error)
  return error_.GetNoArena();
}
inline void ResponseException::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseException.error)
}
#if LANG_CXX11
inline void ResponseException::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseException.error)
}
#endif
inline void ResponseException::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseException.error)
}
inline void ResponseException::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseException.error)
}
inline ::std::string* ResponseException::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseException.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseException::release_error() {
  // @@protoc_insertion_point(field_release:types.ResponseException.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseException::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseException.error)
}

// -------------------------------------------------------------------

// ResponseEcho

// string message = 1;
inline void ResponseEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseEcho::message() const {
  // @@protoc_insertion_point(field_get:types.ResponseEcho.message)
  return message_.GetNoArena();
}
inline void ResponseEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseEcho.message)
}
#if LANG_CXX11
inline void ResponseEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseEcho.message)
}
#endif
inline void ResponseEcho::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseEcho.message)
}
inline void ResponseEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseEcho.message)
}
inline ::std::string* ResponseEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseEcho::release_message() {
  // @@protoc_insertion_point(field_release:types.ResponseEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseEcho::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseEcho.message)
}

// -------------------------------------------------------------------

// ResponseFlush

// -------------------------------------------------------------------

// ResponseInfo

// string data = 1;
inline void ResponseInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.data)
  return data_.GetNoArena();
}
inline void ResponseInfo::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseInfo.data)
}
#if LANG_CXX11
inline void ResponseInfo::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseInfo.data)
}
#endif
inline void ResponseInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseInfo.data)
}
inline void ResponseInfo::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseInfo.data)
}
inline ::std::string* ResponseInfo::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseInfo.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInfo.data)
}

// string version = 2;
inline void ResponseInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::version() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.version)
  return version_.GetNoArena();
}
inline void ResponseInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseInfo.version)
}
#if LANG_CXX11
inline void ResponseInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseInfo.version)
}
#endif
inline void ResponseInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseInfo.version)
}
inline void ResponseInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseInfo.version)
}
inline ::std::string* ResponseInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_version() {
  // @@protoc_insertion_point(field_release:types.ResponseInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInfo.version)
}

// int64 last_block_height = 3;
inline void ResponseInfo::clear_last_block_height() {
  last_block_height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseInfo::last_block_height() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.last_block_height)
  return last_block_height_;
}
inline void ResponseInfo::set_last_block_height(::google::protobuf::int64 value) {
  
  last_block_height_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseInfo.last_block_height)
}

// bytes last_block_app_hash = 4;
inline void ResponseInfo::clear_last_block_app_hash() {
  last_block_app_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::last_block_app_hash() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.GetNoArena();
}
inline void ResponseInfo::set_last_block_app_hash(const ::std::string& value) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseInfo.last_block_app_hash)
}
#if LANG_CXX11
inline void ResponseInfo::set_last_block_app_hash(::std::string&& value) {
  
  last_block_app_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseInfo.last_block_app_hash)
}
#endif
inline void ResponseInfo::set_last_block_app_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseInfo.last_block_app_hash)
}
inline void ResponseInfo::set_last_block_app_hash(const void* value, size_t size) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseInfo.last_block_app_hash)
}
inline ::std::string* ResponseInfo::mutable_last_block_app_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_last_block_app_hash() {
  // @@protoc_insertion_point(field_release:types.ResponseInfo.last_block_app_hash)
  
  return last_block_app_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_last_block_app_hash(::std::string* last_block_app_hash) {
  if (last_block_app_hash != NULL) {
    
  } else {
    
  }
  last_block_app_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_block_app_hash);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInfo.last_block_app_hash)
}

// -------------------------------------------------------------------

// ResponseSetOption

// uint32 code = 1;
inline void ResponseSetOption::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseSetOption::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseSetOption.code)
  return code_;
}
inline void ResponseSetOption::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseSetOption.code)
}

// string log = 3;
inline void ResponseSetOption::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseSetOption::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseSetOption.log)
  return log_.GetNoArena();
}
inline void ResponseSetOption::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseSetOption.log)
}
#if LANG_CXX11
inline void ResponseSetOption::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseSetOption.log)
}
#endif
inline void ResponseSetOption::set_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseSetOption.log)
}
inline void ResponseSetOption::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseSetOption.log)
}
inline ::std::string* ResponseSetOption::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseSetOption.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSetOption::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseSetOption.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSetOption::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseSetOption.log)
}

// string info = 4;
inline void ResponseSetOption::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseSetOption::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseSetOption.info)
  return info_.GetNoArena();
}
inline void ResponseSetOption::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseSetOption.info)
}
#if LANG_CXX11
inline void ResponseSetOption::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseSetOption.info)
}
#endif
inline void ResponseSetOption::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseSetOption.info)
}
inline void ResponseSetOption::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseSetOption.info)
}
inline ::std::string* ResponseSetOption::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseSetOption.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSetOption::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseSetOption.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSetOption::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseSetOption.info)
}

// -------------------------------------------------------------------

// ResponseInitChain

// -------------------------------------------------------------------

// ResponseQuery

// uint32 code = 1;
inline void ResponseQuery::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseQuery::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.code)
  return code_;
}
inline void ResponseQuery::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseQuery.code)
}

// string log = 3;
inline void ResponseQuery::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.log)
  return log_.GetNoArena();
}
inline void ResponseQuery::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.log)
}
#if LANG_CXX11
inline void ResponseQuery::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.log)
}
#endif
inline void ResponseQuery::set_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.log)
}
inline void ResponseQuery::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.log)
}
inline ::std::string* ResponseQuery::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.log)
}

// string info = 4;
inline void ResponseQuery::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.info)
  return info_.GetNoArena();
}
inline void ResponseQuery::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.info)
}
#if LANG_CXX11
inline void ResponseQuery::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.info)
}
#endif
inline void ResponseQuery::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.info)
}
inline void ResponseQuery::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.info)
}
inline ::std::string* ResponseQuery::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.info)
}

// int64 index = 5;
inline void ResponseQuery::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseQuery::index() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.index)
  return index_;
}
inline void ResponseQuery::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseQuery.index)
}

// bytes key = 6;
inline void ResponseQuery::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::key() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.key)
  return key_.GetNoArena();
}
inline void ResponseQuery::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.key)
}
#if LANG_CXX11
inline void ResponseQuery::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.key)
}
#endif
inline void ResponseQuery::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.key)
}
inline void ResponseQuery::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.key)
}
inline ::std::string* ResponseQuery::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_key() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.key)
}

// bytes value = 7;
inline void ResponseQuery::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::value() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.value)
  return value_.GetNoArena();
}
inline void ResponseQuery::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.value)
}
#if LANG_CXX11
inline void ResponseQuery::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.value)
}
#endif
inline void ResponseQuery::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.value)
}
inline void ResponseQuery::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.value)
}
inline ::std::string* ResponseQuery::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_value() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.value)
}

// bytes proof = 8;
inline void ResponseQuery::clear_proof() {
  proof_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::proof() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.proof)
  return proof_.GetNoArena();
}
inline void ResponseQuery::set_proof(const ::std::string& value) {
  
  proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.proof)
}
#if LANG_CXX11
inline void ResponseQuery::set_proof(::std::string&& value) {
  
  proof_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.proof)
}
#endif
inline void ResponseQuery::set_proof(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.proof)
}
inline void ResponseQuery::set_proof(const void* value, size_t size) {
  
  proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.proof)
}
inline ::std::string* ResponseQuery::mutable_proof() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.proof)
  return proof_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_proof() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.proof)
  
  return proof_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_proof(::std::string* proof) {
  if (proof != NULL) {
    
  } else {
    
  }
  proof_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proof);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.proof)
}

// int64 height = 9;
inline void ResponseQuery::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseQuery::height() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.height)
  return height_;
}
inline void ResponseQuery::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseQuery.height)
}

// -------------------------------------------------------------------

// ResponseBeginBlock

// -------------------------------------------------------------------

// ResponseCheckTx

// uint32 code = 1;
inline void ResponseCheckTx::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseCheckTx::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.code)
  return code_;
}
inline void ResponseCheckTx::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.code)
}

// bytes data = 2;
inline void ResponseCheckTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.data)
  return data_.GetNoArena();
}
inline void ResponseCheckTx::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.data)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.data)
}
#endif
inline void ResponseCheckTx::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.data)
}
inline void ResponseCheckTx::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.data)
}
inline ::std::string* ResponseCheckTx::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.data)
}

// string log = 3;
inline void ResponseCheckTx::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.log)
  return log_.GetNoArena();
}
inline void ResponseCheckTx::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.log)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.log)
}
#endif
inline void ResponseCheckTx::set_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.log)
}
inline void ResponseCheckTx::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.log)
}
inline ::std::string* ResponseCheckTx::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.log)
}

// string info = 4;
inline void ResponseCheckTx::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.info)
  return info_.GetNoArena();
}
inline void ResponseCheckTx::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.info)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.info)
}
#endif
inline void ResponseCheckTx::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.info)
}
inline void ResponseCheckTx::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.info)
}
inline ::std::string* ResponseCheckTx::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.info)
}

// int64 gas_wanted = 5;
inline void ResponseCheckTx::clear_gas_wanted() {
  gas_wanted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseCheckTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.gas_wanted)
  return gas_wanted_;
}
inline void ResponseCheckTx::set_gas_wanted(::google::protobuf::int64 value) {
  
  gas_wanted_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.gas_wanted)
}

// int64 gas_used = 6;
inline void ResponseCheckTx::clear_gas_used() {
  gas_used_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseCheckTx::gas_used() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.gas_used)
  return gas_used_;
}
inline void ResponseCheckTx::set_gas_used(::google::protobuf::int64 value) {
  
  gas_used_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.gas_used)
}

// repeated .types.KVPair tags = 7;
inline int ResponseCheckTx::tags_size() const {
  return tags_.size();
}
inline void ResponseCheckTx::clear_tags() {
  tags_.Clear();
}
inline const ::types::KVPair& ResponseCheckTx::tags(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.tags)
  return tags_.Get(index);
}
inline ::types::KVPair* ResponseCheckTx::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.tags)
  return tags_.Mutable(index);
}
inline ::types::KVPair* ResponseCheckTx::add_tags() {
  // @@protoc_insertion_point(field_add:types.ResponseCheckTx.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::KVPair >*
ResponseCheckTx::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseCheckTx.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::KVPair >&
ResponseCheckTx::tags() const {
  // @@protoc_insertion_point(field_list:types.ResponseCheckTx.tags)
  return tags_;
}

// .types.KI64Pair fee = 8;
inline bool ResponseCheckTx::has_fee() const {
  return this != internal_default_instance() && fee_ != NULL;
}
inline void ResponseCheckTx::clear_fee() {
  if (GetArenaNoVirtual() == NULL && fee_ != NULL) {
    delete fee_;
  }
  fee_ = NULL;
}
inline const ::types::KI64Pair& ResponseCheckTx::fee() const {
  const ::types::KI64Pair* p = fee_;
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.fee)
  return p != NULL ? *p : *reinterpret_cast<const ::types::KI64Pair*>(
      &::types::_KI64Pair_default_instance_);
}
inline ::types::KI64Pair* ResponseCheckTx::release_fee() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.fee)
  
  ::types::KI64Pair* temp = fee_;
  fee_ = NULL;
  return temp;
}
inline ::types::KI64Pair* ResponseCheckTx::mutable_fee() {
  
  if (fee_ == NULL) {
    fee_ = new ::types::KI64Pair;
  }
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.fee)
  return fee_;
}
inline void ResponseCheckTx::set_allocated_fee(::types::KI64Pair* fee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fee_;
  }
  if (fee) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.fee)
}

// -------------------------------------------------------------------

// ResponseDeliverTx

// uint32 code = 1;
inline void ResponseDeliverTx::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseDeliverTx::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.code)
  return code_;
}
inline void ResponseDeliverTx::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.code)
}

// bytes data = 2;
inline void ResponseDeliverTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.data)
  return data_.GetNoArena();
}
inline void ResponseDeliverTx::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.data)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.data)
}
#endif
inline void ResponseDeliverTx::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.data)
}
inline void ResponseDeliverTx::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.data)
}
inline ::std::string* ResponseDeliverTx::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.data)
}

// string log = 3;
inline void ResponseDeliverTx::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.log)
  return log_.GetNoArena();
}
inline void ResponseDeliverTx::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.log)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.log)
}
#endif
inline void ResponseDeliverTx::set_log(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.log)
}
inline void ResponseDeliverTx::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.log)
}
inline ::std::string* ResponseDeliverTx::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.log)
}

// string info = 4;
inline void ResponseDeliverTx::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.info)
  return info_.GetNoArena();
}
inline void ResponseDeliverTx::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.info)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.info)
}
#endif
inline void ResponseDeliverTx::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.info)
}
inline void ResponseDeliverTx::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.info)
}
inline ::std::string* ResponseDeliverTx::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.info)
}

// int64 gas_wanted = 5;
inline void ResponseDeliverTx::clear_gas_wanted() {
  gas_wanted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseDeliverTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.gas_wanted)
  return gas_wanted_;
}
inline void ResponseDeliverTx::set_gas_wanted(::google::protobuf::int64 value) {
  
  gas_wanted_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.gas_wanted)
}

// int64 gas_used = 6;
inline void ResponseDeliverTx::clear_gas_used() {
  gas_used_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseDeliverTx::gas_used() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.gas_used)
  return gas_used_;
}
inline void ResponseDeliverTx::set_gas_used(::google::protobuf::int64 value) {
  
  gas_used_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.gas_used)
}

// repeated .types.KVPair tags = 7;
inline int ResponseDeliverTx::tags_size() const {
  return tags_.size();
}
inline void ResponseDeliverTx::clear_tags() {
  tags_.Clear();
}
inline const ::types::KVPair& ResponseDeliverTx::tags(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.tags)
  return tags_.Get(index);
}
inline ::types::KVPair* ResponseDeliverTx::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.tags)
  return tags_.Mutable(index);
}
inline ::types::KVPair* ResponseDeliverTx::add_tags() {
  // @@protoc_insertion_point(field_add:types.ResponseDeliverTx.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::KVPair >*
ResponseDeliverTx::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseDeliverTx.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::KVPair >&
ResponseDeliverTx::tags() const {
  // @@protoc_insertion_point(field_list:types.ResponseDeliverTx.tags)
  return tags_;
}

// .types.KI64Pair fee = 8;
inline bool ResponseDeliverTx::has_fee() const {
  return this != internal_default_instance() && fee_ != NULL;
}
inline void ResponseDeliverTx::clear_fee() {
  if (GetArenaNoVirtual() == NULL && fee_ != NULL) {
    delete fee_;
  }
  fee_ = NULL;
}
inline const ::types::KI64Pair& ResponseDeliverTx::fee() const {
  const ::types::KI64Pair* p = fee_;
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.fee)
  return p != NULL ? *p : *reinterpret_cast<const ::types::KI64Pair*>(
      &::types::_KI64Pair_default_instance_);
}
inline ::types::KI64Pair* ResponseDeliverTx::release_fee() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.fee)
  
  ::types::KI64Pair* temp = fee_;
  fee_ = NULL;
  return temp;
}
inline ::types::KI64Pair* ResponseDeliverTx::mutable_fee() {
  
  if (fee_ == NULL) {
    fee_ = new ::types::KI64Pair;
  }
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.fee)
  return fee_;
}
inline void ResponseDeliverTx::set_allocated_fee(::types::KI64Pair* fee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fee_;
  }
  if (fee) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.fee)
}

// -------------------------------------------------------------------

// ResponseEndBlock

// repeated .types.Validator validator_updates = 1;
inline int ResponseEndBlock::validator_updates_size() const {
  return validator_updates_.size();
}
inline void ResponseEndBlock::clear_validator_updates() {
  validator_updates_.Clear();
}
inline const ::types::Validator& ResponseEndBlock::validator_updates(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseEndBlock.validator_updates)
  return validator_updates_.Get(index);
}
inline ::types::Validator* ResponseEndBlock::mutable_validator_updates(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseEndBlock.validator_updates)
  return validator_updates_.Mutable(index);
}
inline ::types::Validator* ResponseEndBlock::add_validator_updates() {
  // @@protoc_insertion_point(field_add:types.ResponseEndBlock.validator_updates)
  return validator_updates_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::Validator >*
ResponseEndBlock::mutable_validator_updates() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseEndBlock.validator_updates)
  return &validator_updates_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Validator >&
ResponseEndBlock::validator_updates() const {
  // @@protoc_insertion_point(field_list:types.ResponseEndBlock.validator_updates)
  return validator_updates_;
}

// .types.ConsensusParams consensus_param_updates = 2;
inline bool ResponseEndBlock::has_consensus_param_updates() const {
  return this != internal_default_instance() && consensus_param_updates_ != NULL;
}
inline void ResponseEndBlock::clear_consensus_param_updates() {
  if (GetArenaNoVirtual() == NULL && consensus_param_updates_ != NULL) {
    delete consensus_param_updates_;
  }
  consensus_param_updates_ = NULL;
}
inline const ::types::ConsensusParams& ResponseEndBlock::consensus_param_updates() const {
  const ::types::ConsensusParams* p = consensus_param_updates_;
  // @@protoc_insertion_point(field_get:types.ResponseEndBlock.consensus_param_updates)
  return p != NULL ? *p : *reinterpret_cast<const ::types::ConsensusParams*>(
      &::types::_ConsensusParams_default_instance_);
}
inline ::types::ConsensusParams* ResponseEndBlock::release_consensus_param_updates() {
  // @@protoc_insertion_point(field_release:types.ResponseEndBlock.consensus_param_updates)
  
  ::types::ConsensusParams* temp = consensus_param_updates_;
  consensus_param_updates_ = NULL;
  return temp;
}
inline ::types::ConsensusParams* ResponseEndBlock::mutable_consensus_param_updates() {
  
  if (consensus_param_updates_ == NULL) {
    consensus_param_updates_ = new ::types::ConsensusParams;
  }
  // @@protoc_insertion_point(field_mutable:types.ResponseEndBlock.consensus_param_updates)
  return consensus_param_updates_;
}
inline void ResponseEndBlock::set_allocated_consensus_param_updates(::types::ConsensusParams* consensus_param_updates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete consensus_param_updates_;
  }
  if (consensus_param_updates) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      consensus_param_updates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, consensus_param_updates, submessage_arena);
    }
    
  } else {
    
  }
  consensus_param_updates_ = consensus_param_updates;
  // @@protoc_insertion_point(field_set_allocated:types.ResponseEndBlock.consensus_param_updates)
}

// -------------------------------------------------------------------

// ResponseCommit

// bytes data = 2;
inline void ResponseCommit::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCommit::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseCommit.data)
  return data_.GetNoArena();
}
inline void ResponseCommit::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCommit.data)
}
#if LANG_CXX11
inline void ResponseCommit::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCommit.data)
}
#endif
inline void ResponseCommit::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCommit.data)
}
inline void ResponseCommit::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCommit.data)
}
inline ::std::string* ResponseCommit::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCommit.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCommit::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseCommit.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCommit::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCommit.data)
}

// -------------------------------------------------------------------

// ConsensusParams

// .types.BlockSize block_size = 1;
inline bool ConsensusParams::has_block_size() const {
  return this != internal_default_instance() && block_size_ != NULL;
}
inline void ConsensusParams::clear_block_size() {
  if (GetArenaNoVirtual() == NULL && block_size_ != NULL) {
    delete block_size_;
  }
  block_size_ = NULL;
}
inline const ::types::BlockSize& ConsensusParams::block_size() const {
  const ::types::BlockSize* p = block_size_;
  // @@protoc_insertion_point(field_get:types.ConsensusParams.block_size)
  return p != NULL ? *p : *reinterpret_cast<const ::types::BlockSize*>(
      &::types::_BlockSize_default_instance_);
}
inline ::types::BlockSize* ConsensusParams::release_block_size() {
  // @@protoc_insertion_point(field_release:types.ConsensusParams.block_size)
  
  ::types::BlockSize* temp = block_size_;
  block_size_ = NULL;
  return temp;
}
inline ::types::BlockSize* ConsensusParams::mutable_block_size() {
  
  if (block_size_ == NULL) {
    block_size_ = new ::types::BlockSize;
  }
  // @@protoc_insertion_point(field_mutable:types.ConsensusParams.block_size)
  return block_size_;
}
inline void ConsensusParams::set_allocated_block_size(::types::BlockSize* block_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_size_;
  }
  if (block_size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block_size, submessage_arena);
    }
    
  } else {
    
  }
  block_size_ = block_size;
  // @@protoc_insertion_point(field_set_allocated:types.ConsensusParams.block_size)
}

// .types.TxSize tx_size = 2;
inline bool ConsensusParams::has_tx_size() const {
  return this != internal_default_instance() && tx_size_ != NULL;
}
inline void ConsensusParams::clear_tx_size() {
  if (GetArenaNoVirtual() == NULL && tx_size_ != NULL) {
    delete tx_size_;
  }
  tx_size_ = NULL;
}
inline const ::types::TxSize& ConsensusParams::tx_size() const {
  const ::types::TxSize* p = tx_size_;
  // @@protoc_insertion_point(field_get:types.ConsensusParams.tx_size)
  return p != NULL ? *p : *reinterpret_cast<const ::types::TxSize*>(
      &::types::_TxSize_default_instance_);
}
inline ::types::TxSize* ConsensusParams::release_tx_size() {
  // @@protoc_insertion_point(field_release:types.ConsensusParams.tx_size)
  
  ::types::TxSize* temp = tx_size_;
  tx_size_ = NULL;
  return temp;
}
inline ::types::TxSize* ConsensusParams::mutable_tx_size() {
  
  if (tx_size_ == NULL) {
    tx_size_ = new ::types::TxSize;
  }
  // @@protoc_insertion_point(field_mutable:types.ConsensusParams.tx_size)
  return tx_size_;
}
inline void ConsensusParams::set_allocated_tx_size(::types::TxSize* tx_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tx_size_;
  }
  if (tx_size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tx_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx_size, submessage_arena);
    }
    
  } else {
    
  }
  tx_size_ = tx_size;
  // @@protoc_insertion_point(field_set_allocated:types.ConsensusParams.tx_size)
}

// .types.BlockGossip block_gossip = 3;
inline bool ConsensusParams::has_block_gossip() const {
  return this != internal_default_instance() && block_gossip_ != NULL;
}
inline void ConsensusParams::clear_block_gossip() {
  if (GetArenaNoVirtual() == NULL && block_gossip_ != NULL) {
    delete block_gossip_;
  }
  block_gossip_ = NULL;
}
inline const ::types::BlockGossip& ConsensusParams::block_gossip() const {
  const ::types::BlockGossip* p = block_gossip_;
  // @@protoc_insertion_point(field_get:types.ConsensusParams.block_gossip)
  return p != NULL ? *p : *reinterpret_cast<const ::types::BlockGossip*>(
      &::types::_BlockGossip_default_instance_);
}
inline ::types::BlockGossip* ConsensusParams::release_block_gossip() {
  // @@protoc_insertion_point(field_release:types.ConsensusParams.block_gossip)
  
  ::types::BlockGossip* temp = block_gossip_;
  block_gossip_ = NULL;
  return temp;
}
inline ::types::BlockGossip* ConsensusParams::mutable_block_gossip() {
  
  if (block_gossip_ == NULL) {
    block_gossip_ = new ::types::BlockGossip;
  }
  // @@protoc_insertion_point(field_mutable:types.ConsensusParams.block_gossip)
  return block_gossip_;
}
inline void ConsensusParams::set_allocated_block_gossip(::types::BlockGossip* block_gossip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_gossip_;
  }
  if (block_gossip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block_gossip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block_gossip, submessage_arena);
    }
    
  } else {
    
  }
  block_gossip_ = block_gossip;
  // @@protoc_insertion_point(field_set_allocated:types.ConsensusParams.block_gossip)
}

// -------------------------------------------------------------------

// BlockSize

// int32 max_bytes = 1;
inline void BlockSize::clear_max_bytes() {
  max_bytes_ = 0;
}
inline ::google::protobuf::int32 BlockSize::max_bytes() const {
  // @@protoc_insertion_point(field_get:types.BlockSize.max_bytes)
  return max_bytes_;
}
inline void BlockSize::set_max_bytes(::google::protobuf::int32 value) {
  
  max_bytes_ = value;
  // @@protoc_insertion_point(field_set:types.BlockSize.max_bytes)
}

// int32 max_txs = 2;
inline void BlockSize::clear_max_txs() {
  max_txs_ = 0;
}
inline ::google::protobuf::int32 BlockSize::max_txs() const {
  // @@protoc_insertion_point(field_get:types.BlockSize.max_txs)
  return max_txs_;
}
inline void BlockSize::set_max_txs(::google::protobuf::int32 value) {
  
  max_txs_ = value;
  // @@protoc_insertion_point(field_set:types.BlockSize.max_txs)
}

// int64 max_gas = 3;
inline void BlockSize::clear_max_gas() {
  max_gas_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockSize::max_gas() const {
  // @@protoc_insertion_point(field_get:types.BlockSize.max_gas)
  return max_gas_;
}
inline void BlockSize::set_max_gas(::google::protobuf::int64 value) {
  
  max_gas_ = value;
  // @@protoc_insertion_point(field_set:types.BlockSize.max_gas)
}

// -------------------------------------------------------------------

// TxSize

// int32 max_bytes = 1;
inline void TxSize::clear_max_bytes() {
  max_bytes_ = 0;
}
inline ::google::protobuf::int32 TxSize::max_bytes() const {
  // @@protoc_insertion_point(field_get:types.TxSize.max_bytes)
  return max_bytes_;
}
inline void TxSize::set_max_bytes(::google::protobuf::int32 value) {
  
  max_bytes_ = value;
  // @@protoc_insertion_point(field_set:types.TxSize.max_bytes)
}

// int64 max_gas = 2;
inline void TxSize::clear_max_gas() {
  max_gas_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TxSize::max_gas() const {
  // @@protoc_insertion_point(field_get:types.TxSize.max_gas)
  return max_gas_;
}
inline void TxSize::set_max_gas(::google::protobuf::int64 value) {
  
  max_gas_ = value;
  // @@protoc_insertion_point(field_set:types.TxSize.max_gas)
}

// -------------------------------------------------------------------

// BlockGossip

// int32 block_part_size_bytes = 1;
inline void BlockGossip::clear_block_part_size_bytes() {
  block_part_size_bytes_ = 0;
}
inline ::google::protobuf::int32 BlockGossip::block_part_size_bytes() const {
  // @@protoc_insertion_point(field_get:types.BlockGossip.block_part_size_bytes)
  return block_part_size_bytes_;
}
inline void BlockGossip::set_block_part_size_bytes(::google::protobuf::int32 value) {
  
  block_part_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:types.BlockGossip.block_part_size_bytes)
}

// -------------------------------------------------------------------

// Header

// string chain_id = 1;
inline void Header::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::chain_id() const {
  // @@protoc_insertion_point(field_get:types.Header.chain_id)
  return chain_id_.GetNoArena();
}
inline void Header::set_chain_id(const ::std::string& value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.chain_id)
}
#if LANG_CXX11
inline void Header::set_chain_id(::std::string&& value) {
  
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.chain_id)
}
#endif
inline void Header::set_chain_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.chain_id)
}
inline void Header::set_chain_id(const char* value, size_t size) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.chain_id)
}
inline ::std::string* Header::mutable_chain_id() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_chain_id() {
  // @@protoc_insertion_point(field_release:types.Header.chain_id)
  
  return chain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != NULL) {
    
  } else {
    
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:types.Header.chain_id)
}

// int64 height = 2;
inline void Header::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::height() const {
  // @@protoc_insertion_point(field_get:types.Header.height)
  return height_;
}
inline void Header::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.Header.height)
}

// int64 time = 3;
inline void Header::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::time() const {
  // @@protoc_insertion_point(field_get:types.Header.time)
  return time_;
}
inline void Header::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:types.Header.time)
}

// int32 num_txs = 4;
inline void Header::clear_num_txs() {
  num_txs_ = 0;
}
inline ::google::protobuf::int32 Header::num_txs() const {
  // @@protoc_insertion_point(field_get:types.Header.num_txs)
  return num_txs_;
}
inline void Header::set_num_txs(::google::protobuf::int32 value) {
  
  num_txs_ = value;
  // @@protoc_insertion_point(field_set:types.Header.num_txs)
}

// .types.BlockID last_block_id = 5;
inline bool Header::has_last_block_id() const {
  return this != internal_default_instance() && last_block_id_ != NULL;
}
inline void Header::clear_last_block_id() {
  if (GetArenaNoVirtual() == NULL && last_block_id_ != NULL) {
    delete last_block_id_;
  }
  last_block_id_ = NULL;
}
inline const ::types::BlockID& Header::last_block_id() const {
  const ::types::BlockID* p = last_block_id_;
  // @@protoc_insertion_point(field_get:types.Header.last_block_id)
  return p != NULL ? *p : *reinterpret_cast<const ::types::BlockID*>(
      &::types::_BlockID_default_instance_);
}
inline ::types::BlockID* Header::release_last_block_id() {
  // @@protoc_insertion_point(field_release:types.Header.last_block_id)
  
  ::types::BlockID* temp = last_block_id_;
  last_block_id_ = NULL;
  return temp;
}
inline ::types::BlockID* Header::mutable_last_block_id() {
  
  if (last_block_id_ == NULL) {
    last_block_id_ = new ::types::BlockID;
  }
  // @@protoc_insertion_point(field_mutable:types.Header.last_block_id)
  return last_block_id_;
}
inline void Header::set_allocated_last_block_id(::types::BlockID* last_block_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete last_block_id_;
  }
  if (last_block_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_block_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_block_id, submessage_arena);
    }
    
  } else {
    
  }
  last_block_id_ = last_block_id;
  // @@protoc_insertion_point(field_set_allocated:types.Header.last_block_id)
}

// bytes last_commit_hash = 6;
inline void Header::clear_last_commit_hash() {
  last_commit_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::last_commit_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.last_commit_hash)
  return last_commit_hash_.GetNoArena();
}
inline void Header::set_last_commit_hash(const ::std::string& value) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.last_commit_hash)
}
#if LANG_CXX11
inline void Header::set_last_commit_hash(::std::string&& value) {
  
  last_commit_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.last_commit_hash)
}
#endif
inline void Header::set_last_commit_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.last_commit_hash)
}
inline void Header::set_last_commit_hash(const void* value, size_t size) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.last_commit_hash)
}
inline ::std::string* Header::mutable_last_commit_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.last_commit_hash)
  return last_commit_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_last_commit_hash() {
  // @@protoc_insertion_point(field_release:types.Header.last_commit_hash)
  
  return last_commit_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_last_commit_hash(::std::string* last_commit_hash) {
  if (last_commit_hash != NULL) {
    
  } else {
    
  }
  last_commit_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_commit_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.last_commit_hash)
}

// bytes data_hash = 7;
inline void Header::clear_data_hash() {
  data_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::data_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.data_hash)
  return data_hash_.GetNoArena();
}
inline void Header::set_data_hash(const ::std::string& value) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.data_hash)
}
#if LANG_CXX11
inline void Header::set_data_hash(::std::string&& value) {
  
  data_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.data_hash)
}
#endif
inline void Header::set_data_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.data_hash)
}
inline void Header::set_data_hash(const void* value, size_t size) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.data_hash)
}
inline ::std::string* Header::mutable_data_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.data_hash)
  return data_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_data_hash() {
  // @@protoc_insertion_point(field_release:types.Header.data_hash)
  
  return data_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_data_hash(::std::string* data_hash) {
  if (data_hash != NULL) {
    
  } else {
    
  }
  data_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.data_hash)
}

// bytes validators_hash = 8;
inline void Header::clear_validators_hash() {
  validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::validators_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.validators_hash)
  return validators_hash_.GetNoArena();
}
inline void Header::set_validators_hash(const ::std::string& value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.validators_hash)
}
#if LANG_CXX11
inline void Header::set_validators_hash(::std::string&& value) {
  
  validators_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.validators_hash)
}
#endif
inline void Header::set_validators_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.validators_hash)
}
inline void Header::set_validators_hash(const void* value, size_t size) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.validators_hash)
}
inline ::std::string* Header::mutable_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.validators_hash)
  return validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_validators_hash() {
  // @@protoc_insertion_point(field_release:types.Header.validators_hash)
  
  return validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_validators_hash(::std::string* validators_hash) {
  if (validators_hash != NULL) {
    
  } else {
    
  }
  validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), validators_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.validators_hash)
}

// bytes app_hash = 9;
inline void Header::clear_app_hash() {
  app_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::app_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.app_hash)
  return app_hash_.GetNoArena();
}
inline void Header::set_app_hash(const ::std::string& value) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.app_hash)
}
#if LANG_CXX11
inline void Header::set_app_hash(::std::string&& value) {
  
  app_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.app_hash)
}
#endif
inline void Header::set_app_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.app_hash)
}
inline void Header::set_app_hash(const void* value, size_t size) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.app_hash)
}
inline ::std::string* Header::mutable_app_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.app_hash)
  return app_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_app_hash() {
  // @@protoc_insertion_point(field_release:types.Header.app_hash)
  
  return app_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_app_hash(::std::string* app_hash) {
  if (app_hash != NULL) {
    
  } else {
    
  }
  app_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.app_hash)
}

// -------------------------------------------------------------------

// BlockID

// bytes hash = 1;
inline void BlockID::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockID::hash() const {
  // @@protoc_insertion_point(field_get:types.BlockID.hash)
  return hash_.GetNoArena();
}
inline void BlockID::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.BlockID.hash)
}
#if LANG_CXX11
inline void BlockID::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.BlockID.hash)
}
#endif
inline void BlockID::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.BlockID.hash)
}
inline void BlockID::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.BlockID.hash)
}
inline ::std::string* BlockID::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.BlockID.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockID::release_hash() {
  // @@protoc_insertion_point(field_release:types.BlockID.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockID::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:types.BlockID.hash)
}

// .types.PartSetHeader parts = 2;
inline bool BlockID::has_parts() const {
  return this != internal_default_instance() && parts_ != NULL;
}
inline void BlockID::clear_parts() {
  if (GetArenaNoVirtual() == NULL && parts_ != NULL) {
    delete parts_;
  }
  parts_ = NULL;
}
inline const ::types::PartSetHeader& BlockID::parts() const {
  const ::types::PartSetHeader* p = parts_;
  // @@protoc_insertion_point(field_get:types.BlockID.parts)
  return p != NULL ? *p : *reinterpret_cast<const ::types::PartSetHeader*>(
      &::types::_PartSetHeader_default_instance_);
}
inline ::types::PartSetHeader* BlockID::release_parts() {
  // @@protoc_insertion_point(field_release:types.BlockID.parts)
  
  ::types::PartSetHeader* temp = parts_;
  parts_ = NULL;
  return temp;
}
inline ::types::PartSetHeader* BlockID::mutable_parts() {
  
  if (parts_ == NULL) {
    parts_ = new ::types::PartSetHeader;
  }
  // @@protoc_insertion_point(field_mutable:types.BlockID.parts)
  return parts_;
}
inline void BlockID::set_allocated_parts(::types::PartSetHeader* parts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parts_;
  }
  if (parts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parts, submessage_arena);
    }
    
  } else {
    
  }
  parts_ = parts;
  // @@protoc_insertion_point(field_set_allocated:types.BlockID.parts)
}

// -------------------------------------------------------------------

// PartSetHeader

// int32 total = 1;
inline void PartSetHeader::clear_total() {
  total_ = 0;
}
inline ::google::protobuf::int32 PartSetHeader::total() const {
  // @@protoc_insertion_point(field_get:types.PartSetHeader.total)
  return total_;
}
inline void PartSetHeader::set_total(::google::protobuf::int32 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:types.PartSetHeader.total)
}

// bytes hash = 2;
inline void PartSetHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartSetHeader::hash() const {
  // @@protoc_insertion_point(field_get:types.PartSetHeader.hash)
  return hash_.GetNoArena();
}
inline void PartSetHeader::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.PartSetHeader.hash)
}
#if LANG_CXX11
inline void PartSetHeader::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.PartSetHeader.hash)
}
#endif
inline void PartSetHeader::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.PartSetHeader.hash)
}
inline void PartSetHeader::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.PartSetHeader.hash)
}
inline ::std::string* PartSetHeader::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.PartSetHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartSetHeader::release_hash() {
  // @@protoc_insertion_point(field_release:types.PartSetHeader.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartSetHeader::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:types.PartSetHeader.hash)
}

// -------------------------------------------------------------------

// Validator

// bytes pub_key = 1;
inline void Validator::clear_pub_key() {
  pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Validator::pub_key() const {
  // @@protoc_insertion_point(field_get:types.Validator.pub_key)
  return pub_key_.GetNoArena();
}
inline void Validator::set_pub_key(const ::std::string& value) {
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Validator.pub_key)
}
#if LANG_CXX11
inline void Validator::set_pub_key(::std::string&& value) {
  
  pub_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Validator.pub_key)
}
#endif
inline void Validator::set_pub_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Validator.pub_key)
}
inline void Validator::set_pub_key(const void* value, size_t size) {
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Validator.pub_key)
}
inline ::std::string* Validator::mutable_pub_key() {
  
  // @@protoc_insertion_point(field_mutable:types.Validator.pub_key)
  return pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Validator::release_pub_key() {
  // @@protoc_insertion_point(field_release:types.Validator.pub_key)
  
  return pub_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Validator::set_allocated_pub_key(::std::string* pub_key) {
  if (pub_key != NULL) {
    
  } else {
    
  }
  pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pub_key);
  // @@protoc_insertion_point(field_set_allocated:types.Validator.pub_key)
}

// int64 power = 2;
inline void Validator::clear_power() {
  power_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Validator::power() const {
  // @@protoc_insertion_point(field_get:types.Validator.power)
  return power_;
}
inline void Validator::set_power(::google::protobuf::int64 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:types.Validator.power)
}

// -------------------------------------------------------------------

// Evidence

// bytes pub_key = 1;
inline void Evidence::clear_pub_key() {
  pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Evidence::pub_key() const {
  // @@protoc_insertion_point(field_get:types.Evidence.pub_key)
  return pub_key_.GetNoArena();
}
inline void Evidence::set_pub_key(const ::std::string& value) {
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Evidence.pub_key)
}
#if LANG_CXX11
inline void Evidence::set_pub_key(::std::string&& value) {
  
  pub_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Evidence.pub_key)
}
#endif
inline void Evidence::set_pub_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Evidence.pub_key)
}
inline void Evidence::set_pub_key(const void* value, size_t size) {
  
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Evidence.pub_key)
}
inline ::std::string* Evidence::mutable_pub_key() {
  
  // @@protoc_insertion_point(field_mutable:types.Evidence.pub_key)
  return pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Evidence::release_pub_key() {
  // @@protoc_insertion_point(field_release:types.Evidence.pub_key)
  
  return pub_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Evidence::set_allocated_pub_key(::std::string* pub_key) {
  if (pub_key != NULL) {
    
  } else {
    
  }
  pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pub_key);
  // @@protoc_insertion_point(field_set_allocated:types.Evidence.pub_key)
}

// int64 height = 2;
inline void Evidence::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Evidence::height() const {
  // @@protoc_insertion_point(field_get:types.Evidence.height)
  return height_;
}
inline void Evidence::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.Evidence.height)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_types_2eproto__INCLUDED
